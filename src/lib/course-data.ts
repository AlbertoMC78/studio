






export interface CourseClass {
  id: string;
  title: string;
  content: string;
  duration: number; // in minutes
}

export interface CourseModule {
  id: string;
  title:string;
  objective: string;
  classes: CourseClass[];
  project: {
    title: string;
    description: string;
  };
  quizId: string;
}

export const courseData: CourseModule[] = [
  {
    id: '0',
    title: 'MÓDULO 0: Introducción y Ruta de Aprendizaje',
    objective:
      'Entender cómo se estructura el curso, herramientas necesarias y mentalidad del desarrollador',
    classes: [
      {
        id: '0.1',
        title: 'Bienvenida y objetivos del curso',
        content:
          '<h1>Bienvenida al Master Web Developer</h1><p>En este curso, te embarcarás en un viaje completo para convertirte en un desarrollador web de élite. Cubriremos desde los fundamentos hasta tecnologías avanzadas como IA y Web3.</p>',
        duration: 15,
      },
      {
        id: '0.2',
        title: 'Modalidades de estudio y plataformas',
        content:
          '<h2>Modalidades de Estudio</h2><p>Esta plataforma está diseñada para el autoaprendizaje. Sigue los módulos en orden y aprovecha los quizzes y proyectos para solidificar tu conocimiento.</p>',
        duration: 20,
      },
      {
        id: '0.3',
        title: 'Instalación de herramientas básicas',
        content:
          '<h2>Herramientas Esenciales</h2><p>Necesitarás un editor de código como VS Code, Git para control de versiones, y Node.js. Te guiaremos en la instalación.</p>',
        duration: 45,
      },
      {
        id: '0.4',
        title: 'Mentalidad de programador y resolución de problemas',
        content: '<h2>Mentalidad de Programador</h2><p>Contenido sobre la mentalidad de un programador y cómo abordar la resolución de problemas de manera efectiva.</p>',
        duration: 30,
      },
      {
        id: '0.5',
        title: 'Cómo estudiar programación (hábitos + metodología)',
        content: '<h2>Metodología de Estudio</h2><p>Aprende las mejores técnicas y hábitos para estudiar programación de manera eficiente y sostenible a largo plazo.</p>',
        duration: 30,
      },
    ],
    project: {
      title: 'Configuración de Entorno',
      description:
        'Instala todas las herramientas necesarias y configura tu cuenta de GitHub.',
    },
    quizId: 'quiz_0',
  },
  {
    id: '1',
    title: 'MÓDULO 1: Fundamentos de la Web (HTML, CSS, Git)',
    objective:
      'Aprender cómo funciona la web, crear estructuras con HTML y estilos con CSS',
    classes: [
      {
        id: '1.1',
        title: '¿Cómo funciona la Web?',
        content:
          '<h2>El Viaje de una Página Web: Del Clic a la Pantalla</h2>\n<p>Cada vez que visitas un sitio web, desencadenas una serie de eventos rapidísimos y complejos a través de una red global. La arquitectura que lo hace posible se conoce como el <strong>modelo Cliente-Servidor</strong>. Es la columna vertebral de la World Wide Web.</p>\n\n<h3>1. Los Actores Principales</h3>\n<ul>\n  <li><strong>El Cliente (Tu Navegador):</strong> Es el software en tu dispositivo (Chrome, Firefox, Safari) que actúa como tu agente en la web. Su trabajo es solicitar, recibir e interpretar (renderizar) la información para que puedas verla y interactuar con ella.</li>\n  <li><strong>El Servidor:</strong> Es un ordenador potente, siempre encendido y conectado a internet, cuyo propósito es "servir" contenido cuando un cliente lo solicita. Almacena los archivos (HTML, CSS, JavaScript, imágenes), ejecuta lógica de negocio y se conecta a bases de datos.</li>\n</ul>\n\n<h3>2. El Protocolo de Comunicación: HTTP/S</h3>\n<p>Cliente y servidor necesitan un lenguaje común para entenderse. Este lenguaje es el <strong>Protocolo de Transferencia de Hipertexto (HTTP)</strong>. Su versión segura, <strong>HTTPS</strong>, encripta la comunicación, lo cual es el estándar hoy en día.</p>\n<ul>\n    <li><strong>Petición (Request):</strong> El cliente envía una petición HTTP al servidor. Por ejemplo: <code>GET /index.html</code>, que significa "dame el archivo index.html". Otros métodos comunes son <code>POST</code> (para enviar datos), <code>PUT</code> (para actualizar) y <code>DELETE</code> (para borrar). La petición también incluye cabeceras (headers) con metadatos, como el tipo de navegador que usas.</li>\n    <li><strong>Respuesta (Response):</strong> El servidor procesa la petición y devuelve una respuesta HTTP, que incluye un <strong>código de estado</strong> (como <code>200 OK</code> si todo fue bien, o <code>404 Not Found</code> si no encontró el recurso) y el contenido solicitado (el archivo HTML, por ejemplo).</li>\n</ul>\n\n<h3>3. Las Direcciones de la Web: IP y DNS</h3>\n<p>Para que tu navegador sepa a qué servidor enviar la petición, necesita su dirección. En internet, las direcciones son numéricas, llamadas <strong>direcciones IP</strong> (ej., <code>172.217.16.142</code>).</p>\n<p>Como recordar números es difícil para los humanos, usamos nombres de dominio (ej., <code>google.com</code>). El <strong>Sistema de Nombres de Dominio (DNS)</strong> actúa como la agenda telefónica de internet, traduciendo los nombres de dominio que escribimos a la dirección IP del servidor correspondiente.</p>\n\n<h3>4. El Proceso Completo (Paso a Paso)</h3>\n<ol>\n  <li><strong>Escribes la URL:</strong> Ingresas <code>https://www.ejemplo.com</code> en tu navegador y presionas Enter.</li>\n  <li><strong>Traducción DNS:</strong> Tu navegador pregunta a un servidor DNS: "¿Cuál es la IP de <code>www.ejemplo.com</code>?". El DNS responde con la dirección IP del servidor.</li>\n  <li><strong>Petición HTTP/S:</strong> Tu navegador establece una conexión con el servidor en esa IP y le envía una petición HTTP/S pidiendo la página principal.</li>\n  <li><strong>Procesamiento del Servidor:</strong> El servidor recibe la petición. Busca el archivo HTML solicitado. Si es una página dinámica (ej., un perfil de red social), puede que necesite consultar una base de datos y construir el HTML sobre la marcha.</li>\n  <li><strong>Respuesta del Servidor:</strong> El servidor envía el archivo HTML de vuelta a tu navegador como parte de la respuesta HTTP/S.</li>\n  <li><strong>Renderizado (Fase 1 - HTML):</strong> El navegador comienza a leer el HTML. Entiende la estructura: aquí va un título, aquí un párrafo, aquí una imagen.</li>\n  <li><strong>Peticiones Adicionales:</strong> Mientras lee el HTML, el navegador encuentra referencias a otros archivos, como hojas de estilo CSS (<code>&lt;link rel="stylesheet" href="style.css"&gt;</code>) y scripts de JavaScript (<code>&lt;script src="app.js"&gt;&lt;/script&gt;</code>). Realiza peticiones HTTP/S adicionales para cada uno de estos archivos.</li>\n  <li><strong>Renderizado (Fase 2 - CSS y JS):</strong> A medida que llegan los archivos CSS y JavaScript, el navegador los aplica. El CSS le da estilo y apariencia visual a la estructura HTML. El JavaScript añade interactividad, como animaciones, validación de formularios o la capacidad de cargar más contenido sin recargar la página.</li>\n</ol>\n<p>Este ciclo completo, desde la petición inicial hasta que la página es completamente visible e interactiva, ocurre en cuestión de segundos o incluso milisegundos, gracias a la eficiencia de esta arquitectura fundamental.</p>\n<hr/>\n<h3>Recursos Complementarios</h3>\n<h4>Videos Recomendados</h4>\n<ul>\n    <li><strong>(Español) ¿Cómo funciona Internet?</strong> - Un excelente resumen visual de Platzi: <a href="https://www.youtube.com/watch?v=JExO2i-QW4A" target="_blank" rel="noopener noreferrer">Ver en YouTube</a></li>\n    <li><strong>(Inglés) How the Web Works: A Primer for Newcomers to Web Development</strong> - Una explicación clara y concisa de MDN: <a href="https://www.youtube.com/watch?v=hJHvdBlSxug" target="_blank" rel="noopener noreferrer">Ver en YouTube</a></li>\n    <li><strong>(Inglés, Técnico) HTTP Crash Course & Core Concepts</strong> - Un video más profundo de Traversy Media: <a href="https://www.youtube.com/watch?v=iYM2zFP3Zn0" target="_blank" rel="noopener noreferrer">Ver en YouTube</a></li>\n</ul>\n<h4>Lecturas Oficiales</h4>\n<ul>\n    <li><strong>MDN Web Docs: ¿Cómo funciona la web?</strong> - La documentación de referencia para desarrolladores: <a href="https://developer.mozilla.org/es/docs/Learn/Getting_started_with_the_web/How_the_Web_works" target="_blank" rel="noopener noreferrer">Leer artículo</a></li>\n</ul>',
        duration: 30,
      },
      {
        id: '1.2',
        title: 'HTML básico: etiquetas, listas, tablas, enlaces',
        content:
          '<h2>Los Cimientos de la Web: Estructura con HTML</h2>\n<p>HTML (HyperText Markup Language) no es un lenguaje de programación; es un <strong>lenguaje de marcado</strong>. Su única función es describir y estructurar el contenido de una página web. Le dice al navegador qué es un título, qué es un párrafo, dónde va una imagen, etc.</p>\n\n<h3>1. La Anatomía de una Etiqueta HTML</h3>\n<p>Casi todo en HTML está compuesto por <strong>elementos</strong>, que generalmente consisten en una etiqueta de apertura y una de cierre, envolviendo el contenido.</p>\n<pre><code class="language-html">&lt;p&gt;Este es el contenido de un párrafo.&lt;/p&gt;\n&lt;!--  |   |                       |  --&gt;\n&lt;!--  1   2                       3  --&gt;</code></pre>\n<ol>\n  <li><strong>Etiqueta de apertura:</strong> <code>&lt;p&gt;</code>. Indica el inicio de un elemento.</li>\n  <li><strong>Contenido:</strong> El texto o los otros elementos que van dentro.</li>\n  <li><strong>Etiqueta de cierre:</strong> <code>&lt;/p&gt;</code>. Igual que la de apertura, pero con una barra inclinada (<code>/</code>). Indica el final del elemento.</li>\n</ol>\n<p>Algunos elementos son "vacíos" o "auto-cerrados", lo que significa que no tienen contenido ni etiqueta de cierre, como la etiqueta de imagen <code>&lt;img&gt;</code> o la de salto de línea <code>&lt;br&gt;</code>.</p>\n\n<h3>2. Estructura Básica de un Documento HTML</h3>\n<p>Todo archivo <code>.html</code> sigue una estructura fundamental:</p>\n<pre><code class="language-html">&lt;!DOCTYPE html&gt;\n&lt;html lang="es"&gt;\n  &lt;head&gt;\n    &lt;meta charset="UTF-8"&gt;\n    &lt;title&gt;Título de la Página&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;!-- El contenido visible va aquí --&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<ul>\n    <li><code>&lt;!DOCTYPE html&gt;</code>: Declaración que define que el documento es HTML5.</li>\n    <li><code>&lt;html&gt;</code>: El elemento raíz de la página.</li>\n    <li><code>&lt;head&gt;</code>: Contiene metadatos (información sobre el documento), como el título (<code>&lt;title&gt;</code>) que aparece en la pestaña del navegador, enlaces a CSS y el juego de caracteres.</li>\n    <li><code>&lt;body&gt;</code>: Contiene todo el contenido visible de la página web.</li>\n</ul>\n\n<h3>3. Etiquetas Esenciales para Contenido</h3>\n\n<h4>Títulos (Headings)</h4>\n<p>Se usan para titular secciones y subsecciones. Van del <code>&lt;h1&gt;</code> (el más importante) al <code>&lt;h6&gt;</code> (el menos importante).</p>\n<pre><code class="language-html">&lt;h1&gt;Título Principal del Artículo&lt;/h1&gt;\n&lt;h2&gt;Una sección importante&lt;/h2&gt;\n&lt;p&gt;Texto de esta sección...&lt;/p&gt;</code></pre>\n\n<h4>Párrafos (Paragraphs)</h4>\n<p>La etiqueta <code>&lt;p&gt;</code> se usa para bloques de texto.</p>\n\n<h4>Enlaces (Anchors)</h4>\n<p>La etiqueta <code>&lt;a&gt;</code> crea hipervínculos. El atributo <code>href</code> (hypertext reference) especifica la URL de destino.</p>\n<pre><code class="language-html">&lt;a href="https://www.google.com"&gt;Ir a Google&lt;/a&gt;</code></pre>\n\n<h4>Listas</h4>\n<p>Hay dos tipos principales:</p>\n<ul>\n    <li><strong>Listas desordenadas (<code>&lt;ul&gt;</code>):</strong> Para ítems sin un orden particular. Cada ítem se define con <code>&lt;li&gt;</code>.</li>\n    <li><strong>Listas ordenadas (<code>&lt;ol&gt;</code>):</strong> Para ítems secuenciales (1, 2, 3...). Cada ítem también se define con <code>&lt;li&gt;</code>.</li>\n</ul>\n<pre><code class="language-html">&lt;h4&gt;Lista de la compra:&lt;/h4&gt;\n&lt;ul&gt;\n  &lt;li&gt;Leche&lt;/li&gt;\n  &lt;li&gt;Pan&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;h4&gt;Pasos para hacer café:&lt;/h4&gt;\n&lt;ol&gt;\n  &lt;li&gt;Hervir agua&lt;/li&gt;\n  &lt;li&gt;Añadir café&lt;/li&gt;\n  &lt;li&gt;Servir&lt;/li&gt;\n&lt;/ol&gt;</code></pre>\n\n<h4>Tablas</h4>\n<p>Se usan para mostrar datos tabulares. Son una estructura de filas y celdas.</p>\n<ul>\n    <li><code>&lt;table&gt;</code>: Envuelve toda la tabla.</li>\n    <li><code>&lt;thead&gt;</code>: Contiene la fila de cabecera.</li>\n    <li><code>&lt;tbody&gt;</code>: Contiene el cuerpo de la tabla.</li>\n    <li><code>&lt;tr&gt;</code> (table row): Define una fila.</li>\n    <li><code>&lt;th&gt;</code> (table header): Define una celda de cabecera.</li>\n    <li><code>&lt;td&gt;</code> (table data): Define una celda de datos.</li>\n</ul>\n<pre><code class="language-html">&lt;table&gt;\n  &lt;thead&gt;\n    &lt;tr&gt;\n      &lt;th&gt;Nombre&lt;/th&gt;\n      &lt;th&gt;Edad&lt;/th&gt;\n    &lt;/tr&gt;\n  &lt;/thead&gt;\n  &lt;tbody&gt;\n    &lt;tr&gt;\n      &lt;td&gt;Ana&lt;/td&gt;\n      &lt;td&gt;25&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/tbody&gt;\n&lt;/table&gt;</code></pre>\n<p>Estas etiquetas son los bloques de construcción fundamentales. Dominarlas te permitirá crear la estructura de cualquier página web que imagines.</p>\n<hr/>\n<h3>Recursos Complementarios</h3>\n<h4>Videos Recomendados</h4>\n<ul>\n    <li><strong>(Español) Curso HTML5 desde cero</strong> - Un curso completo en video por EDteam: <a href="https://www.youtube.com/watch?v=k2IydkL3_oE" target="_blank" rel="noopener noreferrer">Ver en YouTube</a></li>\n    <li><strong>(Inglés) HTML Full Course for Beginners</strong> - Un video exhaustivo de Traversy Media: <a href="https://www.youtube.com/watch?v=mJgBOIoGihA" target="_blank" rel="noopener noreferrer">Ver en YouTube</a></li>\n</ul>\n<h4>Lecturas Oficiales</h4>\n<ul>\n    <li><strong>MDN Web Docs: HTML basics</strong> - La guía de referencia principal para HTML: <a href="https://developer.mozilla.org/es/docs/Learn/Getting_started_with_the_web/HTML_basics" target="_blank" rel="noopener noreferrer">Leer artículo</a></li>\n</ul>',
        duration: 60,
      },
      {
        id: '1.3',
        title: 'HTML semántico y buenas prácticas',
        content:
          '<h2>La Magia del Contexto: HTML Semántico</h2>\n<p>Has aprendido a usar etiquetas HTML para estructurar tu contenido. Ahora, demos un paso más allá. El <strong>HTML Semántico</strong> consiste en elegir la etiqueta HTML correcta según el <strong>significado</strong> de su contenido, no por cómo se ve en el navegador.</p>\n<p>Piensa en etiquetas como <code>&lt;div&gt;</code> y <code>&lt;span&gt;</code>. Son "no semánticas"; no nos dicen nada sobre el contenido que envuelven. En cambio, etiquetas como <code>&lt;h1&gt;</code>, <code>&lt;p&gt;</code> o <code>&lt;article&gt;</code> le dan un propósito claro a su contenido.</p>\n\n<h3>¿Por qué es tan importante?</h3>\n<ol>\n  <li><strong>Accesibilidad:</strong> Las tecnologías de asistencia, como los lectores de pantalla para personas con discapacidad visual, utilizan la semántica para interpretar y navegar una página. Un lector de pantalla puede anunciar "Navegación principal" si usas una etiqueta <code>&lt;nav&gt;</code>, permitiendo al usuario saltar directamente a ella.</li>\n  <li><strong>SEO (Search Engine Optimization):</strong> Los motores de búsqueda como Google analizan la estructura de tu página para entender de qué trata. Usar <code>&lt;h1&gt;</code> para tu título principal y <code>&lt;section&gt;</code> para agrupar contenido relacionado les ayuda a indexar tu sitio de manera más efectiva, lo que puede mejorar tu ranking en los resultados de búsqueda.</li>\n  <li><strong>Mantenibilidad:</strong> Un código semántico es más fácil de leer y entender para otros desarrolladores (¡y para tu yo del futuro!). Es auto-documentado.</li>\n</ol>\n\n<h3>Las Etiquetas Semánticas de Layout Principales</h3>\n<p>HTML5 introdujo un conjunto de etiquetas diseñadas para estructurar las secciones principales de una página web.</p>\n\n<pre><code class="language-html">&lt;body&gt;\n  &lt;header&gt;\n    &lt;!-- Contenido introductorio o de navegación --&gt;\n    &lt;h1&gt;Mi Blog Increíble&lt;/h1&gt;\n    &lt;nav&gt;\n      &lt;ul&gt;\n        &lt;li&gt;&lt;a href="/"&gt;Inicio&lt;/a&gt;&lt;/li&gt;\n        &lt;li&gt;&lt;a href="/acerca"&gt;Acerca de&lt;/a&gt;&lt;/li&gt;\n      &lt;/ul&gt;\n    &lt;/nav&gt;\n  &lt;/header&gt;\n\n  &lt;main&gt;\n    &lt;!-- El contenido principal y único de esta página --&gt;\n    &lt;article&gt;\n      &lt;h2&gt;Título del Artículo&lt;/h2&gt;\n      &lt;p&gt;Contenido del artículo...&lt;/p&gt;\n      &lt;section&gt;\n        &lt;h3&gt;Comentarios&lt;/h3&gt;\n        &lt;p&gt;Primer comentario...&lt;/p&gt;\n      &lt;/section&gt;\n    &lt;/article&gt;\n\n    &lt;aside&gt;\n      &lt;h3&gt;Publicidad&lt;/h3&gt;\n      &lt;p&gt;Contenido relacionado pero no esencial.&lt;/p&gt;\n    &lt;/aside&gt;\n  &lt;/main&gt;\n\n  &lt;footer&gt;\n    &lt;!-- Pie de página con info de contacto, copyright, etc. --&gt;\n    &lt;p&gt;&copy; 2024 Mi Blog Increíble&lt;/p&gt;\n  &lt;/footer&gt;\n&lt;/body&gt;\n</code></pre>\n\n<ul>\n    <li><code>&lt;header&gt;</code>: Representa el encabezado de una página o sección. Suele contener el logo, el título principal y la navegación.</li>\n    <li><code>&lt;nav&gt;</code>: Define un bloque de enlaces de navegación principal.</li>\n    <li><code>&lt;main&gt;</code>: ¡Crucial! Envuelve el contenido <strong>principal y único</strong> del documento. Solo debe haber uno por página y no debe estar anidado dentro de otras etiquetas de layout como <code>&lt;article&gt;</code>, <code>&lt;aside&gt;</code>, <code>&lt;footer&gt;</code>, o <code>&lt;header&gt;</code>.</li>\n    <li><code>&lt;article&gt;</code>: Representa un bloque de contenido independiente y auto-contenido que podría existir por sí solo y tener sentido, como una entrada de blog, un post en un foro o un artículo de noticias.</li>\n    <li><code>&lt;section&gt;</code>: Agrupa contenido temáticamente relacionado. Es una forma más genérica de agrupar contenido que <code>&lt;article&gt;</code>. Generalmente, una sección debe tener su propio encabezado (h2-h6).</li>\n    <li><code>&lt;aside&gt;</code>: Para contenido tangencialmente relacionado con el contenido principal, como barras laterales, publicidad o biografías de autor.</li>\n    <li><code>&lt;footer&gt;</code>: Define el pie de página de un documento o sección. Suele contener información de autoría, copyright, enlaces a políticas, etc.</li>\n</ul>\n\n<h3>Buenas Prácticas</h3>\n<ul>\n    <li><strong>No abuses de los <code>&lt;div&gt;</code>:</strong> Antes de usar un <code>&lt;div&gt;</code>, pregúntate: "¿Hay una etiqueta semántica más apropiada para este contenido?". Usa los <code>div</code> principalmente para fines de estilado cuando no hay otra opción.</li>\n    <li><strong>Jerarquía de Títulos:</strong> Usa los títulos (<code>&lt;h1&gt;</code>-<code>&lt;h6&gt;</code>) en orden lógico. No saltes de un <code>&lt;h1&gt;</code> a un <code>&lt;h3&gt;</code> porque te gusta cómo se ve. La apariencia se controla con CSS; el HTML es para la estructura.</li>\n    <li><strong>El atributo <code>alt</code> en imágenes:</strong> Siempre incluye un texto alternativo (<code>alt</code>) en tus etiquetas <code>&lt;img&gt;</code>. Describe la imagen para usuarios de lectores de pantalla y también se muestra si la imagen no puede cargar.</li>\n</ul>\n<pre><code class="language-html">&lt;img src="perrito.jpg" alt="Un cachorro de Golden Retriever jugando en la hierba."&gt;\n</code></pre>\n<p>Adoptar el HTML semántico desde el principio es una de las marcas de un desarrollador web profesional. Tu código será más robusto, accesible y comprensible.</p>\n<hr/>\n<h3>Recursos Complementarios</h3>\n<h4>Videos Recomendados</h4>\n<ul>\n    <li><strong>(Español) ¿Qué es HTML Semántico?</strong> - Una explicación clara de la Universidad JavaScript: <a href="https://www.youtube.com/watch?v=T1itpKr822o" target="_blank" rel="noopener noreferrer">Ver en YouTube</a></li>\n</ul>\n<h4>Lecturas Oficiales</h4>\n<ul>\n    <li><strong>MDN Web Docs: HTML Semántico</strong> - Artículo de referencia sobre el tema: <a href="https://developer.mozilla.org/es/docs/Glossary/Semantics" target="_blank" rel="noopener noreferrer">Leer artículo</a></li>\n</ul>',
        duration: 45,
      },
      {
        id: '1.4',
        title: 'CSS básico: selectores, propiedades, colores',
        content:
          '<h2>Dando Vida a la Web: Introducción a CSS</h2>\n<p>Si HTML es el esqueleto de una página web, <strong>CSS (Cascading Style Sheets)</strong> es la piel, la ropa y el maquillaje. Es el lenguaje que usamos para describir cómo se deben presentar visualmente los elementos HTML, controlando todo, desde los colores y las fuentes hasta la disposición de los elementos en la página.</p>\n\n<h3>1. ¿Cómo se conecta el CSS al HTML?</h3>\n<p>La forma más común y recomendada es usar una hoja de estilos externa. Esto implica crear un archivo separado con la extensión <code>.css</code> (por ejemplo, <code>style.css</code>) y enlazarlo desde el <code>&lt;head&gt;</code> de tu documento HTML.</p>\n<pre><code class="language-html">&lt;!-- En tu archivo index.html --&gt;\n&lt;head&gt;\n  &lt;title&gt;Mi Página con Estilo&lt;/title&gt;\n  &lt;link rel="stylesheet" href="style.css"&gt;\n&lt;/head&gt;</code></pre>\n<p>Esta práctica mantiene la estructura (HTML) y la presentación (CSS) separadas, lo que hace que el código sea mucho más fácil de mantener.</p>\n\n<h3>2. La Sintaxis de una Regla CSS</h3>\n<p>Una regla CSS consta de dos partes principales: un <strong>selector</strong> y un <strong>bloque de declaración</strong>.</p>\n<pre><code class="language-css">h1 {\n  color: #0A2342;\n  font-size: 2.5rem;\n}\n/* |  |      |      | */\n/* 1  2      3      4 */\n</code></pre>\n<ol>\n  <li><strong>Selector:</strong> Apunta al elemento(s) HTML que quieres estilizar. En este caso, <code>h1</code> selecciona todos los elementos <code>&lt;h1&gt;</code>.</li>\n  <li><strong>Bloque de declaración:</strong> Envuelto en llaves <code>{ }</code>, contiene una o más declaraciones.</li>\n  <li><strong>Propiedad:</strong> El aspecto que deseas cambiar (ej., <code>color</code>, <code>font-size</code>).</li>\n  <li><strong>Valor:</strong> El valor que quieres asignar a la propiedad (ej., <code>#0A2342</code>, <code>2.5rem</code>). Cada declaración termina con un punto y coma <code>;</code>.</li>\n</ol>\n\n<h3>3. Selectores Fundamentales</h3>\n<p>Para estilizar algo, primero debes seleccionarlo. Aquí están los selectores más básicos:</p>\n<ul>\n    <li><strong>Selector de Etiqueta (o Tipo):</strong> Selecciona todos los elementos de un tipo específico.</li>\n    <pre><code class="language-css">/* Estiliza todos los párrafos */\np {\n  line-height: 1.6;\n}</code></pre>\n    <li><strong>Selector de Clase:</strong> Selecciona todos los elementos que tienen un atributo <code>class</code> específico. Es el selector más versátil y utilizado. Se denota con un punto (<code>.</code>).</li>\n    <pre><code class="language-html">&lt;p class="destacado"&gt;Este párrafo es importante.&lt;/p&gt;</code></pre>\n    <pre><code class="language-css">.destacado {\n  font-weight: bold;\n  color: hsl(var(--accent));\n}</code></pre>\n    <li><strong>Selector de ID:</strong> Selecciona <strong>un único elemento</strong> que tiene un atributo <code>id</code> específico. Un ID debe ser único en toda la página. Se denota con una almohadilla (<code>#</code>).</li>\n    <pre><code class="language-html">&lt;header id="encabezado-principal"&gt;...&lt;/header&gt;</code></pre>\n    <pre><code class="language-css">#encabezado-principal {\n  background-color: #f0f0f0;\n}</code></pre>\n</ul>\n\n<h3>4. Propiedades Básicas y Colores</h3>\n<p>Algunas propiedades comunes para empezar:</p>\n<ul>\n  <li><code>color</code>: Establece el color del texto.</li>\n  <li><code>background-color</code>: Establece el color de fondo de un elemento.</li>\n  <li><code>font-size</code>: Define el tamaño del texto.</li>\n  <li><code>font-family</code>: Define el tipo de letra (fuente) para el texto.</li>\n  <li><code>font-weight</code>: Define el grosor del texto (normal, bold).</li>\n  <li><code>text-align</code>: Alinea el texto (left, center, right).</li>\n</ul>\n\n<h4>Definición de Colores</h4>\n<p>Puedes especificar colores de varias maneras:</p>\n<ul>\n  <li><strong>Nombres de color:</strong> <code>red</code>, <code>blue</code>, <code>green</code> (limitado).</li>\n  <li><strong>HEX:</strong> <code>#RRGGBB</code> (Rojo, Verde, Azul en hexadecimal). Por ejemplo, <code>#FFFFFF</code> es blanco y <code>#0A2342</code> es un azul oscuro.</li>\n  <li><strong>RGB:</strong> <code>rgb(rojo, verde, azul)</code> donde cada valor va de 0 a 255. Por ejemplo, <code>rgb(10, 35, 66)</code>.</li>\n  <li><strong>HSL (Recomendado):</strong> <code>hsl(tono, saturación, luminosidad)</code>. Es muy intuitivo. El tono es un ángulo en la rueda de color (0-360), la saturación es un porcentaje (0% gris, 100% color puro), y la luminosidad es un porcentaje (0% negro, 100% blanco).</li>\n</ul>\n<p>CSS es un lenguaje vasto, pero dominar estos fundamentos (cómo enlazar, la sintaxis de las reglas y los selectores básicos) te da el poder de transformar documentos HTML simples en diseños web atractivos y legibles.</p>\n<hr/>\n<h3>Recursos Complementarios</h3>\n<h4>Videos Recomendados</h4>\n<ul>\n    <li><strong>(Español) Curso CSS desde Cero</strong> - Un excelente curso en video de freeCodeCamp en Español: <a href="https://www.youtube.com/watch?v=Lztd_g_fxw4" target="_blank" rel="noopener noreferrer">Ver en YouTube</a></li>\n    <li><strong>(Inglés) CSS Full Course for Beginners</strong> - Un curso completo de SuperSimpleDev: <a href="https://www.youtube.com/watch?v=G3e-cpL7ofc" target="_blank" rel="noopener noreferrer">Ver en YouTube</a></li>\n</ul>\n<h4>Lecturas Oficiales</h4>\n<ul>\n    <li><strong>MDN Web Docs: Primeros pasos en CSS</strong> - La guía fundamental para empezar: <a href="https://developer.mozilla.org/es/docs/Learn/CSS/First_steps" target="_blank" rel="noopener noreferrer">Leer artículo</a></li>\n</ul>',
        duration: 60,
      },
      {
        id: '1.5',
        title: 'Box model y layout',
        content: '<h2>El Concepto Fundamental de Diseño Web: El Modelo de Caja (Box Model)</h2>\n<p>En CSS, todo elemento HTML es tratado como una caja rectangular. El <strong>Modelo de Caja</strong> es la regla que define cómo se calcula el tamaño de esta caja y cómo interactúa con los demás elementos. Comprenderlo es absolutamente esencial para maquetar (hacer el layout) de cualquier página web.</p>\n<p>Cada caja está compuesta de cuatro partes, ordenadas desde adentro hacia afuera:</p>\n<img src="https://placehold.co/600x400.png" data-ai-hint="css box model diagram" alt="Diagrama del Modelo de Caja de CSS" style="width:100%; max-width:500px; margin: 20px auto; display: block;" />\n\n<h3>1. Content (Contenido)</h3>\n<p>Es el área donde se muestra tu contenido real: texto, una imagen, un video, etc. Sus dimensiones son el <code>width</code> (ancho) y el <code>height</code> (alto) que defines en tu CSS.</p>\n\n<h3>2. Padding (Relleno)</h3>\n<p>Es un espacio transparente que rodea el contenido, separándolo del borde. El padding "empuja" el borde hacia afuera. Es como el margen interior de una hoja de papel.</p>\n<pre><code class="language-css">.mi-caja {\n  padding: 20px; /* 20px de relleno en los 4 lados */\n  padding-top: 10px; /* Relleno solo arriba */\n  padding-left: 15px; /* Relleno solo a la izquierda */\n  /* shorthand: arriba, derecha, abajo, izquierda */\n  padding: 10px 20px 10px 20px; \n}</code></pre>\n\n<h3>3. Border (Borde)</h3>\n<p>Es una línea que se dibuja alrededor del padding y el contenido. El borde tiene un grosor, un estilo y un color.</p>\n<pre><code class="language-css">.mi-caja {\n  border: 2px solid #36454F; /* grosor, estilo, color */\n}</code></pre>\n\n<h3>4. Margin (Margen)</h3>\n<p>Es un espacio transparente que rodea el borde, "empujando" a los otros elementos para crear espacio entre ellos. Es el espacio <em>exterior</em> de la caja.</p>\n<pre><code class="language-css">.mi-caja {\n  margin: 30px; /* 30px de margen en los 4 lados */\n  margin-bottom: 40px; /* Margen solo abajo */\n}</code></pre>\n\n<h3>El Tamaño Total de un Elemento</h3>\n<p>Por defecto, el ancho total de una caja es la suma de: <code>width</code> + <code>padding-left</code> + <code>padding-right</code> + <code>border-left</code> + <code>border-right</code>.</p>\n<p>Esto puede ser poco intuitivo. Si defines <code>width: 200px</code> y luego añades <code>padding: 20px</code>, ¡el ancho visible total será de 240px! Esto causaba muchos dolores de cabeza a los desarrolladores.</p>\n\n<h4>La Solución: `box-sizing: border-box`</h4>\n<p>Para solucionar esto, usamos una regla mágica en CSS que simplifica enormemente el cálculo del tamaño. <code>box-sizing: border-box;</code> le dice al navegador: "Cuando yo defina un <code>width</code> de 200px, quiero que ese sea el ancho <strong>total</strong>, incluyendo el padding y el borde". El navegador entonces ajustará el espacio del contenido hacia adentro para hacerle campo al padding y al borde.</p>\n<p>Es una práctica estándar y altamente recomendada incluir esta regla al inicio de tu CSS para todos los elementos:</p>\n<pre><code class="language-css">*,\n*::before,\n*::after {\n  box-sizing: border-box;\n}</code></pre>\n<p>Con esta simple regla, si declaras <code>width: 200px;</code>, la caja ocupará exactamente 200px de ancho en la pantalla, facilitando enormemente la creación de layouts precisos.</p>\n<p>Dominar el Modelo de Caja es el primer gran paso para dejar de "luchar" con CSS y empezar a decirle exactamente qué hacer y cómo posicionar los elementos con predictibilidad y control.</p>\n<hr/>\n<h3>Recursos Complementarios</h3>\n<h4>Videos Recomendados</h4>\n<ul>\n    <li><strong>(Español) El Modelo de Caja (Box Model) en CSS</strong> - Explicación detallada de FalconMasters: <a href="https://www.youtube.com/watch?v=j352-T4bE0o" target="_blank" rel="noopener noreferrer">Ver en YouTube</a></li>\n</ul>\n<h4>Lecturas Oficiales</h4>\n<ul>\n    <li><strong>MDN Web Docs: El Modelo de Caja</strong> - La documentación oficial sobre este concepto: <a href="https://developer.mozilla.org/es/docs/Learn/CSS/Building_blocks/The_box_model" target="_blank" rel="noopener noreferrer">Leer artículo</a></li>\n</ul>',
        duration: 50,
      },
      {
        id: '1.6',
        title: 'Flexbox y Grid',
        content: '<h2>Layouts Modernos: Flexbox y Grid</h2>\n<p>Hasta ahora, has aprendido a tratar cada elemento como una caja individual. Flexbox y Grid son tecnologías de CSS que te permiten ir más allá, dándote el poder de controlar cómo se organizan y alinean grupos de cajas. Son las herramientas fundamentales para crear cualquier layout moderno y responsivo.</p>\n\n<h3>1. Flexbox: El Poder del Eje Único</h3>\n<p><strong>Flexbox (Flexible Box Layout)</strong> está diseñado para maquetar elementos en una sola dimensión, ya sea una fila o una columna. Es perfecto para alinear ítems, distribuirlos y controlar su orden dentro de un contenedor.</p>\n\n<h4>Conceptos Clave de Flexbox</h4>\n<ul>\n    <li><strong>Contenedor Flex (Flex Container):</strong> Es el elemento padre al que le aplicas <code>display: flex;</code>.</li>\n    <li><strong>Ítems Flex (Flex Items):</strong> Son los hijos directos del contenedor flex.</li>\n    <li><strong>Eje Principal (Main Axis):</strong> La dirección en la que se colocan los ítems flex (por defecto, horizontal).</li>\n    <li><strong>Eje Cruzado (Cross Axis):</strong> El eje perpendicular al eje principal (por defecto, vertical).</li>\n</ul>\n\n<h4>Propiedades del Contenedor (Padre)</h4>\n<ul>\n    <li><code>display: flex;</code>: Activa el contexto de Flexbox.</li>\n    <li><code>flex-direction: row | column;</code>: Establece la dirección del eje principal.</li>\n    <li><code>justify-content</code>: Alinea los ítems a lo largo del eje principal (<code>flex-start</code>, <code>center</code>, <code>flex-end</code>, <code>space-between</code>).</li>\n    <li><code>align-items</code>: Alinea los ítems a lo largo del eje cruzado (<code>flex-start</code>, <code>center</code>, <code>flex-end</code>, <code>stretch</code>).</li>\n    <li><code>flex-wrap: nowrap | wrap;</code>: Permite que los ítems salten a la siguiente línea si no caben.</li>\n</ul>\n\n<pre><code class="language-css">.contenedor-flex {\n  display: flex;\n  justify-content: space-between; /* Distribuye el espacio entre los ítems */\n  align-items: center; /* Centra los ítems verticalmente */\n}</code></pre>\n\n<h3>2. CSS Grid: El Poder de las Dos Dimensiones</h3>\n<p><strong>Grid Layout</strong> es un sistema de maquetación bidimensional. Te permite crear una cuadrícula de filas y columnas donde puedes posicionar elementos de forma precisa. Es ideal para layouts de página complejos.</p>\n\n<h4>Conceptos Clave de Grid</h4>\n<ul>\n    <li><strong>Contenedor Grid (Grid Container):</strong> El elemento padre al que aplicas <code>display: grid;</code>.</li>\n    <li><strong>Ítems Grid (Grid Items):</strong> Los hijos directos del contenedor.</li>\n    <li><strong>Líneas de Grid (Grid Lines):</strong> Las líneas horizontales y verticales que dividen la cuadrícula.</li>\n    <li><strong>Celdas de Grid (Grid Cells):</strong> El espacio entre cuatro líneas de grid.</li>\n    <li><strong>Áreas de Grid (Grid Areas):</strong> Un espacio rectangular que puede abarcar múltiples celdas.</li>\n</ul>\n\n<h4>Propiedades del Contenedor (Padre)</h4>\n<ul>\n    <li><code>display: grid;</code>: Activa el contexto de Grid.</li>\n    <li><code>grid-template-columns</code>: Define el número y tamaño de las columnas (ej: <code>1fr 1fr 2fr;</code> crea tres columnas, la última el doble de ancha).</li>\n    <li><code>grid-template-rows</code>: Define el número y tamaño de las filas (ej: <code>auto 100px;</code>).</li>\n    <li><code>gap</code>: Define el espacio entre filas y columnas (ej: <code>20px;</code>).</li>\n</ul>\n\n<h4>Propiedades de los Ítems (Hijos)</h4>\n<ul>\n    <li><code>grid-column-start / grid-column-end</code>: Define en qué línea de columna empieza y termina un ítem.</li>\n    <li><code>grid-row-start / grid-row-end</code>: Define en qué línea de fila empieza y termina un ítem.</li>\n    <li><code>grid-column</code> y <code>grid-row</code> (shorthand): Abreviaturas para las propiedades anteriores (ej: <code>grid-column: 1 / span 2;</code> abarca desde la línea 1 a la 3).</li>\n</ul>\n\n<pre><code class="language-css">.contenedor-grid {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr); /* Tres columnas de igual tamaño */\n  gap: 1rem;\n}\n\n.item-destacado {\n  grid-column: 1 / span 2; /* Ocupa dos columnas */\n  grid-row: 1;\n}</code></pre>\n\n<h3>¿Cuándo usar Flexbox y cuándo usar Grid?</h3>\n<ul>\n    <li>Usa <strong>Flexbox</strong> para componentes y alineación en una dimensión: barras de navegación, alineación de ítems dentro de una tarjeta, centrado de contenido.</li>\n    <li>Usa <strong>Grid</strong> para el layout general de la página en dos dimensiones: la estructura principal de tu sitio web con encabezado, contenido, barra lateral y pie de página.</li>\n</ul>\n<p>La verdadera maestría viene de combinar ambos. Puedes tener un layout principal hecho con Grid, y dentro de una de las áreas de ese grid, usar Flexbox para alinear los elementos de un componente.</p>\n<hr/>\n<h3>Recursos Complementarios</h3>\n<h4>Videos Recomendados</h4>\n<ul>\n    <li><strong>(Español) Guía Completa de Flexbox y CSS Grid</strong> - Un video que compara y explica ambos, por Dorian Desings: <a href="https://www.youtube.com/watch?v=R-lJofc_I7s" target="_blank" rel="noopener noreferrer">Ver en YouTube</a></li>\n</ul>\n<h4>Juegos Interactivos (¡La mejor forma de aprender!)</h4>\n<ul>\n    <li><strong>Flexbox Froggy:</strong> Un juego para aprender Flexbox de forma interactiva: <a href="https://flexboxfroggy.com/#es" target="_blank" rel="noopener noreferrer">Jugar ahora</a></li>\n    <li><strong>CSS Grid Garden:</strong> El equivalente para aprender CSS Grid: <a href="https://cssgridgarden.com/#es" target="_blank" rel="noopener noreferrer">Jugar ahora</a></li>\n</ul>',
        duration: 90,
      },
      {
        id: '1.7',
        title: 'Introducción a Git y GitHub',
        content:
          '<h2>La Red de Seguridad del Desarrollador: Git y GitHub</h2>\n<p>Imagina que estás escribiendo un documento muy importante. Cada cierto tiempo, guardas una copia con un nombre diferente: "documento_v1", "documento_v2", "documento_final", "documento_final_de_verdad". Esto es engorroso y propenso a errores. El <strong>Control de Versiones</strong> es un sistema que soluciona este problema de manera profesional.</p>\n\n<h3>1. ¿Qué es el Control de Versiones?</h3>\n<p>Es un sistema que registra los cambios realizados en un archivo o conjunto de archivos a lo largo del tiempo, de modo que puedas recuperar versiones específicas más adelante. Es como una máquina del tiempo para tu código. Te permite:</p>\n<ul>\n    <li>Revertir archivos a un estado anterior.</li>\n    <li>Revertir todo el proyecto a un estado anterior.</li>\n    <li>Comparar cambios a lo largo del tiempo.</li>\n    <li>Ver quién modificó algo por última vez que podría estar causando un problema.</li>\n    <li>Trabajar en paralelo con otros desarrolladores sin sobrescribir el trabajo de los demás.</li>\n</ul>\n\n<h3>2. Git: Tu Base de Datos de Cambios Local</h3>\n<p><strong>Git</strong> es el software de control de versiones más popular del mundo. Es un <strong>Sistema de Control de Versiones Distribuido (DVCS)</strong>. Esto significa que no dependes de un servidor central. Cada desarrollador tiene una copia completa del historial del proyecto en su propia máquina.</p>\n<p>Con Git, el flujo de trabajo básico es:</p>\n<ol>\n    <li>Modificas archivos en tu copia de trabajo.</li>\n    <li>Seleccionas los cambios que quieres "guardar" (esto se llama <em>staging</em>).</li>\n    <li>Creas un <em>commit</em>: una instantánea permanente de tus archivos en ese momento, con un mensaje que describe los cambios.</li>\n</ol>\n<p>Toda esta actividad ocurre en tu ordenador, de forma local. Es rápido y no necesitas conexión a internet para ver el historial o hacer commits.</p>\n\n<h3>3. GitHub: Tu Repositorio en la Nube y Plataforma Social</h3>\n<p>Si Git es el software, ¿dónde guardas una copia de seguridad o compartes tu trabajo con otros? Ahí es donde entra <strong>GitHub</strong>.</p>\n<p>GitHub es una plataforma web que aloja repositorios de Git en la nube. Ofrece:</p>\n<ul>\n    <li><strong>Alojamiento de Repositorios Remotos:</strong> Un lugar central (un "remoto") donde puedes "empujar" (<em>push</em>) tus commits. Es la copia de seguridad y la fuente de verdad para el equipo.</li>\n    <li><strong>Colaboración:</strong> Permite que múltiples personas trabajen en el mismo proyecto. Pueden "clonar" (<em>clone</em>) el repositorio, hacer sus cambios y luego proponer integrarlos al proyecto principal a través de un <em>Pull Request</em>.</li>\n    <li><strong>Revisión de Código:</strong> Los Pull Requests son la herramienta clave para la colaboración, permitiendo a otros revisar tus cambios, dejar comentarios y aprobar la integración.</li>\n    <li><strong>Gestión de Proyectos:</strong> Incluye herramientas para seguimiento de errores (<em>Issues</em>), tableros Kanban (<em>Projects</em>) y documentación (<em>Wikis</em>).</li>\n    <li><strong>Portafolio Profesional:</strong> Tu perfil de GitHub se convierte en tu currículum como desarrollador. Muestra los proyectos en los que has trabajado y tus contribuciones a proyectos de código abierto.</li>\n</ul>\n\n<h3>En Resumen: Git vs. GitHub</h3>\n<p>Una analogía útil:</p>\n<ul>\n    <li><strong>Git</strong> es como Microsoft Word: el programa que usas en tu ordenador para escribir y guardar el historial de un documento.</li>\n    <li><strong>GitHub</strong> es como Google Docs o Dropbox: el servicio en la nube donde subes tu documento para tener una copia de seguridad, compartirlo y colaborar con otras personas en tiempo real.</li>\n</ul>\n<p>No se puede ser un desarrollador moderno sin saber Git. Es una habilidad no negociable. GitHub (o alternativas como GitLab o Bitbucket) es el estándar de la industria para trabajar con Git en un entorno profesional y colaborativo.</p>\n<hr/>\n<h3>Recursos Complementarios</h3>\n<h4>Videos Recomendados</h4>\n<ul>\n    <li><strong>(Español) ¿Qué es Git y GitHub? ¡La guía para principiantes!</strong> - Un video introductorio de HolaMundo: <a href="https://www.youtube.com/watch?v=3GymExBkKjE" target="_blank" rel="noopener noreferrer">Ver en YouTube</a></li>\n    <li><strong>(Inglés) Learn Git In 15 Minutes</strong> - Un video conciso y directo de Colt Steele: <a href="https://www.youtube.com/watch?v=USjZgo0sTCA" target="_blank" rel="noopener noreferrer">Ver en YouTube</a></li>\n</ul>\n<h4>Lecturas Oficiales</h4>\n<ul>\n    <li><strong>Libro Pro Git:</strong> El libro oficial y de referencia, disponible gratis online: <a href="https://git-scm.com/book/es/v2" target="_blank" rel="noopener noreferrer">Leer online</a></li>\n</ul>',
        duration: 45,
      },
      {
        id: '1.8',
        title: 'Git básico: commits, ramas, merge',
        content:
          '<h2>Manos a la Obra: Comandos Esenciales de Git</h2>\n<p>Has entendido qué es Git y GitHub. Ahora, es momento de abrir la terminal y aprender los comandos que usarás todos los días. Esta será una guía práctica para el flujo de trabajo básico.</p>\n\n<h3>Configuración Inicial (Solo se hace una vez)</h3>\n<p>Antes de nada, debes decirle a Git quién eres. Esto es importante porque cada commit que hagas usará esta información.</p>\n<pre><code class="language-shell">git config --global user.name "Tu Nombre Completo"\ngit config --global user.email "tu_email@example.com"</code></pre>\n\n<h3>1. Inicializar un Repositorio: `git init`</h3>\n<p>Para empezar a usar Git en un proyecto, navega a la carpeta de tu proyecto en la terminal y ejecuta:</p>\n<pre><code class="language-shell">git init</code></pre>\n<p>Esto crea una subcarpeta oculta llamada <code>.git</code> donde Git almacenará todo el historial y la configuración del proyecto. ¡Tu proyecto ahora es un repositorio de Git!</p>\n\n<h3>2. El Ciclo Básico: Modificar, Añadir, Comprometer</h3>\n<p>Este es el ciclo que repetirás constantemente.</p>\n<h4>Paso A: Revisa el Estado con `git status`</h4>\n<p>Este es tu comando más importante. Te dice qué archivos han sido modificados, cuáles están en el área de preparación (staging) y en qué rama estás.</p>\n<pre><code class="language-shell">git status</code></pre>\n\n<h4>Paso B: Prepara los Cambios con `git add`</h4>\n<p>Git no guarda automáticamente todos los archivos que modificas. Debes decirle explícitamente qué cambios incluir en el próximo "punto de guardado" (commit). Esto se llama <em>staging</em> o preparar los cambios.</p>\n<pre><code class="language-shell"># Prepara un archivo específico\ngit add index.html\n\n# Prepara todos los archivos modificados y nuevos en el directorio actual\ngit add .</code></pre>\n\n<h4>Paso C: Guarda los Cambios con `git commit`</h4>\n<p>Un commit es una instantánea de tus archivos preparados. Cada commit tiene un mensaje que describe los cambios realizados. ¡Los buenos mensajes son cruciales!</p>\n<pre><code class="language-shell">git commit -m "Añade la estructura HTML inicial para la página de inicio"</code></pre>\n\n<h3>3. Ramas (Branches): Trabajando en Paralelo</h3>\n<p>Una rama es una línea de desarrollo independiente. La rama por defecto se llama <code>main</code> (o <code>master</code>). Se crean ramas para trabajar en nuevas funcionalidades o corregir errores sin afectar la versión estable (<code>main</code>).</p>\n<h4>Crear y Cambiar de Rama: `git branch` y `git checkout`</h4>\n<pre><code class="language-shell"># Crea una nueva rama llamada \'nueva-funcionalidad\'\ngit branch nueva-funcionalidad\n\n# Muévete a esa rama para empezar a trabajar en ella\ngit checkout nueva-funcionalidad\n\n# O, un atajo para crear y cambiarte a la rama en un solo paso:\ngit checkout -b nueva-funcionalidad</code></pre>\n\n<h3>4. Fusionar (Merge): Integrando Cambios</h3>\n<p>Una vez que has terminado tu trabajo en una rama, querrás integrar esos cambios de vuelta a tu rama principal (<code>main</code>).</p>\n<pre><code class="language-shell"># 1. Primero, vuelve a tu rama principal\ngit checkout main\n\n# 2. Luego, fusiona los cambios de la otra rama en main\ngit merge nueva-funcionalidad</code></pre>\n<p>Git intentará combinar los cambios automáticamente. A veces, si dos personas han modificado la misma línea de un archivo, ocurrirá un "conflicto de merge", que tendrás que resolver manualmente.</p>\n\n<h3>5. Trabajando con GitHub: `push`</h3>\n<p>Hasta ahora, todos tus commits y ramas están solo en tu máquina. Para subirlos a tu repositorio remoto en GitHub, usas <code>git push</code>.</p>\n<pre><code class="language-shell"># Sube tu rama \'main\' al remoto llamado \'origin\'\ngit push origin main\n\n# Si estás subiendo una rama nueva por primera vez\ngit push --set-upstream origin nueva-funcionalidad</code></pre>\n<p><code>origin</code> es el nombre por defecto que Git le da al repositorio remoto desde el que clonaste. Ahora tus cambios están seguros en la nube y disponibles para tus colaboradores.</p>\n<hr/>\n<h3>Recursos Complementarios</h3>\n<h4>Videos Recomendados</h4>\n<ul>\n    <li><strong>(Español) Git y GitHub - Curso práctico para principiantes</strong> - Un curso práctico de MoureDev: <a href="https://www.youtube.com/watch?v=mBYSUbws4IQ" target="_blank" rel="noopener noreferrer">Ver en YouTube</a></li>\n</ul>\n<h4>Herramientas Interactivas</h4>\n<ul>\n    <li><strong>Learn Git Branching:</strong> Una herramienta visual e interactiva para aprender los comandos de Git, especialmente el manejo de ramas: <a href="https://learngitbranching.js.org/?locale=es_ES" target="_blank" rel="noopener noreferrer">Empezar a aprender</a></li>\n</ul>',
        duration: 60,
      },
    ],
    project: {
      title: 'Página de perfil personal',
      description:
        'Crea tu propia página de perfil usando HTML y CSS, y súbela a un repositorio de GitHub.',
    },
    quizId: 'quiz_1',
  },
  {
    id: '2',
    title: 'MÓDULO 2: JavaScript a Profundidad',
    objective:
      'Dominar JavaScript, su asincronismo y sus paradigmas para resolver problemas complejos.',
    classes: [
      {
        id: '2.1',
        title: 'Variables, Tipos, Coerción y Comparación',
        content:
          '<h2>La Verdad sobre JavaScript: Tipos, Coerción y Comparaciones</h2><p>JavaScript es un lenguaje de "tipado dinámico", lo que significa que no tienes que declarar el tipo de una variable. Esto ofrece flexibilidad, pero también es una fuente común de errores si no se entienden los conceptos de <strong>coerción de tipo</strong> y <strong>comparación estricta</strong>.</p><h3>1. El Sistema de Tipos de JavaScript</h3><p>Los tipos primitivos son la base:</p><ul><li><strong>String:</strong> <code>"hola"</code></li><li><strong>Number:</strong> <code>42</code>, <code>3.14</code> (no hay distinción entre enteros y flotantes)</li><li><strong>Boolean:</strong> <code>true</code>, <code>false</code></li><li><strong>null:</strong> Un valor asignado que significa "sin valor". Es un objeto (un error histórico, pero así funciona).</li><li><strong>undefined:</strong> Una variable que no ha sido asignada.</li><li><strong>Symbol:</strong> Un identificador único e inmutable.</li><li><strong>BigInt:</strong> Para números enteros más grandes de lo que <code>Number</code> puede manejar.</li></ul><p>Y luego tenemos los <strong>Objetos</strong>, que son colecciones de propiedades (incluyendo funciones, que son objetos de primera clase).</p><pre><code class="language-javascript">console.log(typeof 42);         // "number"\\nconsole.log(typeof "Alberto");  // "string"\\nconsole.log(typeof true);       // "boolean"\\nconsole.log(typeof undefined);  // "undefined"\\nconsole.log(typeof null);       // "object" (¡la trampa!)\\nconsole.log(typeof {});         // "object"\\n</code></pre><h3>2. Coerción de Tipo: La Conversión Automática</h3><p>La coerción es la conversión automática de valores de un tipo de dato a otro. Ocurre cuando se usan operadores con valores de tipos diferentes. Es una de las características más potentes y peligrosas de JS.</p><pre><code class="language-javascript">console.log(10 + "5"); // "105" (Number se convierte a String)\\nconsole.log(10 - "5"); // 5     (String se convierte a Number)\\nconsole.log(10 * "5"); // 50    (String se convierte a Number)\\nconsole.log(true + 1); // 2     (Boolean `true` se convierte a 1)\\n</code></pre><p>Aunque a veces es útil, depender de la coerción implícita puede llevar a resultados inesperados y errores difíciles de depurar.</p><h3>3. Comparaciones: El Doble vs. el Triple Igual</h3><p>Aquí es donde la coerción causa más problemas. JavaScript tiene dos operadores de igualdad:</p><h4><code>==</code> (Igualdad Débil o Abstracta)</h4><p>Este operador <strong>permite la coerción de tipo</strong> antes de comparar. Intenta convertir los operandos a un tipo común antes de hacer la comparación.</p><pre><code class="language-javascript">console.log(5 == "5");        // true (coerción)\\nconsole.log(0 == false);      // true (coerción)\\nconsole.log(null == undefined); // true (una regla especial del lenguaje)\\nconsole.log("" == 0);         // true (coerción)\\n</code></pre><p><strong>Regla general: Evita usar <code>==</code> casi siempre.</strong> Las reglas de coerción son complejas y pueden ocultar errores en tu lógica.</p><h4><code>===</code> (Igualdad Estricta)</h4><p>Este operador es tu mejor amigo. Compara los valores <strong>sin permitir coerción de tipo</strong>. Si los tipos son diferentes, inmediatamente devuelve <code>false</code>.</p><pre><code class="language-javascript">console.log(5 === "5");        // false (Number vs String)\\nconsole.log(0 === false);      // false (Number vs Boolean)\\nconsole.log(null === undefined); // false (tipos diferentes)\\n</code></pre><p><strong>Usa siempre la igualdad estricta (<code>===</code> y <code>!==</code>).</strong> Te forzará a ser explícito sobre los tipos con los que trabajas, resultando en un código más predecible, robusto y fácil de entender. Si necesitas convertir un tipo, hazlo tú mismo de forma explícita (p. ej., usando <code>Number(value)</code> o <code>String(value)</code>) en lugar de dejar que JS lo adivine por ti.</p><hr/><h3>Recursos Complementarios</h3><h4>Videos Recomendados</h4><ul><li><strong>(Inglés) JavaScript Showdown: == vs ===</strong> - Un video conciso y claro de Fireship: <a href="https://www.youtube.com/watch?v=s55t64Mma14" target="_blank" rel="noopener noreferrer">Ver en YouTube</a></li></ul><h4>Lecturas Oficiales</h4><ul><li><strong>MDN Web Docs: Igualdad en JS</strong> - La guía definitiva sobre las comparaciones en JavaScript: <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Equality_comparisons_and_sameness" target="_blank" rel="noopener noreferrer">Leer artículo</a></li></ul>',
        duration: 60,
      },
      {
        id: '2.2',
        title: 'El Contexto de `this` y Prototipos',
        content:
          '<h2>El Corazón de JavaScript: Prototipos y el Contexto ‘this‘</h2><p>Para dominar realmente JavaScript, es crucial entender dos de sus conceptos más fundamentales y, a menudo, más confusos: el sistema de herencia basado en <strong>prototipos</strong> y la palabra clave contextual <strong><code>this</code></strong>.</p><h3>1. Herencia Prototípica: La Cadena de Objetos</h3><p>A diferencia de lenguajes como Java o C# que usan "clases", JavaScript utiliza un mecanismo llamado <strong>herencia prototípica</strong>. Cada objeto en JavaScript tiene una propiedad interna oculta (<code>[[Prototype]]</code>) que es una referencia (un "prototipo") a otro objeto. Cuando intentas acceder a una propiedad de un objeto, si el objeto no la tiene, JavaScript busca en su prototipo. Si el prototipo tampoco la tiene, busca en el prototipo del prototipo, y así sucesivamente, hasta llegar a un objeto cuyo prototipo es <code>null</code>. Esta secuencia se conoce como la <strong>cadena de prototipos (prototype chain)</strong>.</p><p>Esto es increíblemente poderoso. Significa que puedes tener un objeto (p. ej., <code>animal</code>) con un método <code>respirar()</code>. Luego, puedes crear otro objeto (p. ej., <code>perro</code>) y establecer su prototipo como <code>animal</code>. Ahora, aunque <code>perro</code> no tenga definido el método <code>respirar()</code>, puedes llamar a <code>perro.respirar()</code> y JavaScript lo encontrará en la cadena de prototipos.</p><pre><code class="language-javascript">const animal = {\\n  respirar: function() {\\n    console.log("Respirando...");\\n  }\\n};\\n\\n// Creamos un objeto `perro` cuyo prototipo es `animal`\\nconst perro = Object.create(animal);\\nperro.ladrar = function() {\\n  console.log("¡Guau!");\\n};\\n\\nperro.ladrar();    // "¡Guau!" (propiedad propia de `perro`)\\nperro.respirar();  // "Respirando..." (heredada de `animal`)\\n</code></pre><p>Las "clases" de JavaScript (introducidas en ES6 con la palabra clave <code>class</code>) son, en gran medida, "azúcar sintáctico" sobre este sistema de prototipos. Simplifican la sintaxis, pero por debajo, la herencia prototípica sigue siendo el motor.</p><h3>2. El Contexto Dinámico: `this`</h3><p>La palabra clave <code>this</code> es una de las características más incomprendidas de JavaScript porque su valor no se determina donde se escribe la función, sino <strong>cómo se llama a la función</strong>. Se refiere al "contexto de ejecución" de la función.</p><p>Aquí están las reglas principales que determinan el valor de <code>this</code>:</p><ol>    <li><strong>Llamada a Método (Method Invocation):</strong> Si una función se llama como una propiedad de un objeto, <code>this</code> se enlaza a ese objeto.</li>    <pre><code class="language-javascript">const persona = {\\n  nombre: "Alberto",\\n  saludar: function() {\\n    console.log("Hola, soy " + this.nombre);\\n  }\\n};\\npersona.saludar(); // this es `persona`. Imprime "Hola, soy Alberto"\\n</code></pre>    <li><strong>Llamada a Función Simple (Simple Function Invocation):</strong> Si una función se llama directamente (no como propiedad de un objeto), <code>this</code> se enlaza al objeto global (<code>window</code> en los navegadores) o es <code>undefined</code> en modo estricto ("use strict"). Este es el origen de muchos errores.</li>    <pre><code class="language-javascript">\'use strict\';\\nfunction quienSoy() {\\n  console.log(this);\\n}\\nquienSoy(); // undefined\\n</code></pre>    <li><strong>Funciones de Flecha (Arrow Functions):</strong> ¡La excepción a la regla! Las funciones de flecha <strong>no tienen su propio <code>this</code></strong>. En su lugar, "heredan" el valor de <code>this</code> del contexto en el que fueron creadas. Esto las hace increíblemente útiles para callbacks y para evitar problemas con el contexto.</li>    <pre><code class="language-javascript">const miObjeto = {\\n  valor: 42,\\n  metodoNormal: function() {\\n    setTimeout(function() {\\n      // `this` aquí es `window` o undefined, ¡perdimos el contexto!\\n      console.log(this.valor); // undefined\\n    }, 1000);\\n  },\\n  metodoConFlecha: function() {\\n    setTimeout(() => {\\n      // La flecha hereda el `this` de `metodoConFlecha`, que es `miObjeto`\\n      console.log(this.valor); // 42 ¡Funciona!\\n    }, 1000);\\n  }\\n};\\nmiObjeto.metodoConFlecha();\\n</code></pre>    <li><strong>Llamada Explícita (<code>.call</code>, <code>.apply</code>, <code>.bind</code>):</strong> Puedes forzar explícitamente el valor de <code>this</code> en una función usando estos métodos.</li></ol><p>Entender que <code>this</code> es dinámico y que las funciones de flecha se comportan de manera diferente es un salto cualitativo en tu habilidad para escribir JavaScript robusto y predecible.</p><hr/><h3>Recursos Complementarios</h3><h4>Videos Recomendados</h4><ul><li><strong>(Inglés) The JavaScript `this` keyword explained in 100 seconds</strong> - Video de Fireship: <a href="https://www.youtube.com/watch?v=gvicrj31JOM" target="_blank" rel="noopener noreferrer">Ver en YouTube</a></li></ul><h4>Lecturas Oficiales</h4><ul><li><strong>MDN Web Docs: Herencia y la cadena de prototipos</strong>: <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener noreferrer">Leer artículo</a></li><li><strong>MDN Web Docs: El operador `this`</strong>: <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="noopener noreferrer">Leer artículo</a></li></ul>',
        duration: 90,
      },
      {
        id: '2.3',
        title: 'Asincronismo: Callbacks, Promesas y Async/Await',
        content:
          '<h2>Manejando el Tiempo: El Modelo Asíncrono de JavaScript</h2><p>JavaScript en su núcleo es un lenguaje <strong>síncrono y de un solo hilo (single-threaded)</strong>. Esto significa que solo puede hacer una cosa a la vez. Si una tarea tarda mucho en completarse (como una petición a un servidor), bloquearía todo el programa. Para solucionar esto, JavaScript utiliza un <strong>modelo de concurrencia asíncrono</strong>, basado en un "event loop" (bucle de eventos).</p><h3>1. El Problema: El Código Bloqueante</h3><p>Imagina que pides datos a una API. Si el código fuera puramente síncrono, la interfaz de usuario se congelaría hasta que llegara la respuesta. No podrías hacer clic en botones ni interactuar con la página. El asincronismo nos permite iniciar una tarea de larga duración y continuar con otras cosas mientras esperamos que termine.</p><h3>2. La Evolución del Asincronismo en JS</h3><h4>Fase 1: Callbacks</h4><p>La forma original de manejar operaciones asíncronas era a través de <strong>funciones de callback</strong>. Pasabas una función como argumento a otra función, y esta se "llamaba de vuelta" (called back) una vez que la tarea asíncrona había finalizado.</p><pre><code class="language-javascript">function descargarDatos(url, callback) {\\n  console.log("Iniciando descarga de " + url);\\n  setTimeout(() => { // Simulamos una petición de red\\n    const datos = "Estos son los datos";\\n    callback(datos);\\n  }, 2000);\\n}\\n\\ndescargarDatos("mi-api.com/datos", function(resultado) {\\n  console.log("Descarga completada:", resultado);\\n});\\n\\nconsole.log("Esta línea se ejecuta antes de que la descarga termine.");\\n</code></pre><p>El problema con los callbacks surge cuando necesitas encadenar varias operaciones asíncronas, una después de la otra. Esto lleva a una anidación profunda de funciones, conocida como el <strong>"Callback Hell"</strong> o "Pyramid of Doom", que es difícil de leer y mantener.</p><h4>Fase 2: Promesas (Promises)</h4><p>Las promesas (introducidas en ES6) son objetos que representan la eventual finalización (o fallo) de una operación asíncrona. Una promesa puede estar en uno de tres estados:</p><ul>    <li><strong>Pending (Pendiente):</strong> El estado inicial; la operación aún no ha terminado.</li>    <li><strong>Fulfilled (Cumplida):</strong> La operación se completó con éxito.</li>    <li><strong>Rejected (Rechazada):</strong> La operación falló.</li></ul><p>Las promesas nos permiten encadenar operaciones asíncronas de una manera mucho más limpia usando los métodos <code>.then()</code> (para el éxito) y <code>.catch()</code> (para el error).</p><pre><code class="language-javascript">function descargarDatosConPromesa(url) {\\n  return new Promise((resolve, reject) => {\\n    console.log("Iniciando descarga con promesa...");\\n    setTimeout(() => {\\n      const exito = true; // Simular éxito o fracaso\\n      if (exito) {\\n        resolve("Datos descargados exitosamente");\\n      } else {\\n        reject("Error en la descarga");\\n      }\\n    }, 2000);\\n  });\\n}\\n\\ndescargarDatosConPromesa("mi-api.com/datos")\\n  .then(resultado => {\\n    console.log("Éxito:", resultado);\\n    return "Procesando " + resultado; // Puedes encadenar más .then\\n  })\\n  .then(nuevoResultado => {\\n    console.log(nuevoResultado);\\n  })\\n  .catch(error => {\\n    console.error("Fallo:", error);\\n  });\\n</code></pre><h4>Fase 3: Async/Await</h4><p><code>async/await</code> (introducido en ES2017) es "azúcar sintáctico" sobre las promesas. No introduce nueva funcionalidad, pero nos permite escribir código asíncrono que <strong>parece síncrono</strong>. Es la forma moderna y preferida de manejar el asincronismo.</p><ul>    <li>La palabra clave <code>async</code> se pone antes de una función para declarar que es una función asíncrona. Estas funciones siempre devuelven una promesa implícitamente.</li>    <li>La palabra clave <code>await</code> se usa <strong>dentro</strong> de una función <code>async</code> para pausar la ejecución de la función y esperar a que una promesa se resuelva.</li></ul><pre><code class="language-javascript">async function gestionarDescarga() {\\n  try {\\n    console.log("Vamos a descargar los datos...");\\n    const resultado = await descargarDatosConPromesa("mi-api.com/datos");\\n    console.log("Éxito:", resultado);\\n    const nuevoResultado = "Procesando " + resultado;\\n    console.log(nuevoResultado);\\n    console.log("Todo terminado.");\\n  } catch (error) {\\n    console.error("Fallo:", error);\\n  }\\n}\\n\\ngestionarDescarga();\\n</code></pre><p>Como puedes ver, el código con <code>async/await</code> es mucho más plano, legible y fácil de razonar, especialmente cuando se manejan errores con bloques <code>try...catch</code>. Entender esta evolución es clave para escribir aplicaciones web modernas y eficientes.</p><hr/><h3>Recursos Complementarios</h3><h4>Videos Recomendados</h4><ul><li><strong>(Español) La GUÍA DEFINITIVA sobre ASINCRONÍA en JAVASCRIPT</strong> - Un video muy completo de La Cocina del Código: <a href="https://www.youtube.com/watch?v=SPv-Sj1p2wA" target="_blank" rel="noopener noreferrer">Ver en YouTube</a></li></ul><h4>Lecturas Oficiales</h4><ul><li><strong>MDN Web Docs: JavaScript Asíncrono</strong> - La guía de referencia de MDN sobre este tema: <a href="https://developer.mozilla.org/es/docs/Learn/JavaScript/Asynchronous" target="_blank" rel="noopener noreferrer">Leer artículo</a></li></ul>',
        duration: 90,
      },
      {
        id: '2.4',
        title: 'Gestión de Errores y Depuración',
        content:
          '<h2>El Arte de la Resiliencia: Gestión de Errores y Depuración</h2><p>Escribir código que funciona cuando todo va bien es solo la mitad del trabajo. Un desarrollador profesional se distingue por su habilidad para anticipar, manejar y corregir errores. Un programa robusto no es aquel que nunca falla, sino aquel que falla de manera predecible y controlada.</p><h3>1. Tipos de Errores</h3><p>En JavaScript, podemos clasificar los errores en varias categorías:</p><ul>    <li><strong>Errores de Sintaxis (Syntax Errors):</strong> Ocurren cuando escribes código que no sigue las reglas gramaticales de JavaScript. El intérprete ni siquiera puede empezar a ejecutar el código. Por ejemplo, olvidar una llave de cierre <code>}</code>.</li>    <li><strong>Errores en Tiempo de Ejecución (Runtime Errors):</strong> Ocurren mientras el código se está ejecutando. El código es sintácticamente válido, pero sucede algo inesperado. Por ejemplo, intentar llamar a un método en una variable <code>null</code> (p. ej., <code>null.toString()</code>).</li>    <li><strong>Errores de Lógica (Logic Errors):</strong> Son los más difíciles de encontrar. El código es válido y se ejecuta sin fallar, pero no produce el resultado esperado. Por ejemplo, un cálculo incorrecto en un carrito de la compra.</li></ul><h3>2. Gestión de Errores en Tiempo de Ejecución: `try...catch...finally`</h3><p>Para manejar los errores que pueden ocurrir en tiempo de ejecución (como una respuesta fallida de una API), usamos el bloque <strong><code>try...catch</code></strong>.</p><ul>    <li><strong><code>try</code>:</strong> Envuelves el código que sospechas que podría lanzar un error dentro de este bloque.</li>    <li><strong><code>catch</code>:</strong> Si se produce un error dentro del bloque <code>try</code>, la ejecución salta inmediatamente a este bloque, pasándole un objeto de error con información sobre lo que salió mal.</li>    <li><strong><code>finally</code>:</strong> Este bloque (opcional) se ejecuta siempre, sin importar si hubo un error o no. Es perfecto para tareas de "limpieza", como cerrar una conexión o quitar un indicador de carga.</li></ul><pre><code class="language-javascript">async function obtenerDatosDeUsuario(id) {\\n  try {\\n    console.log("Intentando obtener datos...");\\n    const respuesta = await fetch(`https://api.example.com/users/${id}`);\\n\\n    if (!respuesta.ok) {\\n      // Lanzamos un error manualmente para ser capturado por el catch\\n      throw new Error(`Error de red: ${respuesta.status}`);\\n    }\\n\\n    const datos = await respuesta.json();\\n    console.log("Datos obtenidos:", datos);\\n    return datos;\\n  } catch (error) {\\n    console.error("Ha ocurrido un problema:", error.message);\\n    // Aquí podríamos mostrar un mensaje de error al usuario\\n  } finally {\\n    console.log("La operación ha finalizado (con o sin éxito).");\\n  }\\n}\\n</code></pre><p>La palabra clave <code>throw</code> te permite crear y lanzar tus propios errores personalizados.</p><h3>3. Depuración (Debugging): El Trabajo de Detective</h3><p>La depuración es el proceso de encontrar y corregir errores, especialmente los de lógica. Las herramientas del desarrollador de tu navegador son tu mejor aliado.</p><h4>La Consola (<code>console</code>)</h4><p>Ya la has estado usando. Es más que solo <code>console.log()</code>. Puedes usar:</p><ul>    <li><code>console.error(\'Mensaje de error\')</code>: Para errores.</li>    <li><code>console.warn(\'Advertencia\')</code>: Para advertencias.</li>    <li><code>console.table(miArrayDeObjetos)</code>: Para mostrar datos tabulares de forma legible.</li></ul><h4>El Depurador (Debugger)</h4><p>Es la herramienta más potente. Te permite pausar la ejecución de tu código en puntos específicos y examinar el estado de tu programa línea por línea.</p><ol>    <li><strong>Breakpoints (Puntos de Ruptura):</strong> Puedes establecer un breakpoint haciendo clic en el número de línea en la pestaña "Sources" (Fuentes) de las herramientas del desarrollador. Cuando el código llegue a esa línea, la ejecución se detendrá.</li>    <li><strong>Inspección de Variables:</strong> Una vez pausado, puedes pasar el ratón por encima de cualquier variable en tu código para ver su valor actual. También puedes ver todas las variables accesibles en el panel "Scope".</li>    <li><strong>Control de Flujo:</strong> Puedes avanzar a la siguiente línea (step over), entrar en una función que se está llamando (step into), o continuar la ejecución hasta el siguiente breakpoint.</li></ol><p>Aprender a usar el depurador de manera efectiva te ahorrará incontables horas de frustración. En lugar de llenar tu código de <code>console.log</code>, puedes detener el tiempo y ver exactamente qué está pasando.</p><hr/><h3>Recursos Complementarios</h3><h4>Videos Recomendados</h4><ul><li><strong>(Español) Cómo DEPURAR CÓDIGO JavaScript</strong> - Guía práctica de La Cocina del Código: <a href="https://www.youtube.com/watch?v=F0sA2vD0A0s" target="_blank" rel="noopener noreferrer">Ver en YouTube</a></li></ul><h4>Lecturas Oficiales</h4><ul><li><strong>MDN Web Docs: try...catch</strong>: <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Statements/try...catch" target="_blank" rel="noopener noreferrer">Leer artículo</a></li><li><strong>MDN Web Docs: Depuración de JavaScript en el navegador</strong>: <a href="https://developer.mozilla.org/es/docs/Learn/Common_questions/Tools_and_setup/What_are_browser_developer_tools#el_depurador_de_javascript" target="_blank" rel="noopener noreferrer">Leer artículo</a></li></ul>',
        duration: 75,
      },
    ],
    project: {
      title: 'Aplicación de Tareas con API Externa',
      description:
        'Crea una ToDo List que obtiene y guarda sus datos de una API REST pública (como JSONPlaceholder), gestionando estados de carga, asincronismo y errores de forma robusta.',
    },
    quizId: 'quiz_2',
  },
  {
    id: '3',
    title: 'MÓDULO 3: Desarrollo Front-End con Frameworks',
    objective: 'Aprender React y fundamentos de otros frameworks populares',
    classes: [
      {
        id: '3.1',
        title: '¿Qué es un framework y por qué usar React?',
        content:
          '<h2>El Ecosistema Moderno: Librerías vs. Frameworks</h2><p>Cuando construyes una aplicación web compleja, no quieres reinventar la rueda para cada funcionalidad. Quieres herramientas que te ayuden a ser más productivo y a escribir código más mantenible. Aquí es donde entran las librerías y los frameworks, pero no son lo mismo.</p><h3>Librería: La Caja de Herramientas</h3><p>Una <strong>librería</strong> es un conjunto de código reutilizable que puedes "llamar" desde tu propio código para realizar tareas específicas. Tú mantienes el control del flujo de la aplicación.</p><p><strong>Ejemplo:</strong> Piensa en <strong>React</strong>. React es, en esencia, una librería para construir interfaces de usuario. Te da herramientas (componentes, hooks) y tú decides cuándo y dónde usarlas en tu aplicación. Tú llamas a React, React no te llama a ti.</p><h3>Framework: El Plan de Construcción</h3><p>Un <strong>framework</strong> es un sistema más completo y opinado. Proporciona una estructura y un esqueleto para tu aplicación. El framework controla el flujo ("inversión de control") y te dice dónde debes colocar tu código. Él llama a tu código, no al revés.</p><p><strong>Ejemplo:</strong> Piensa en <strong>Next.js</strong> (¡que usa React por debajo!), Angular o Vue. Next.js define cómo organizar tus páginas (con el App Router), cómo manejar el routing, cómo obtener datos del servidor, etc. Te da un plan de construcción completo.</p><h3>¿Por qué domina React?</h3><ol><li><strong>Arquitectura Basada en Componentes:</strong> La idea de dividir la UI en piezas pequeñas, reutilizables y autocontenidas (Componentes) fue un cambio de paradigma. Un botón, un formulario, una tarjeta... todo es un componente. Esto hace que las UIs complejas sean mucho más fáciles de gestionar.</li><li><strong>UI Declarativa:</strong> En lugar de dar instrucciones paso a paso sobre cómo cambiar la UI (programación imperativa: "encuentra este elemento, cambia su texto, añade esta clase"), con React simplemente "declaras" cómo debería verse la UI para un estado determinado. React se encarga del "cómo" llegar a ese estado de la manera más eficiente.</li><li><strong>El Virtual DOM:</strong> Manipular el DOM real del navegador es lento. React crea una copia ligera del DOM en memoria (el Virtual DOM). Cuando el estado de tu aplicación cambia, React calcula la forma más eficiente de actualizar el DOM real comparando la versión anterior del Virtual DOM con la nueva, y aplicando solo los cambios mínimos necesarios. Esto resulta en un rendimiento mucho mayor.</li></ol><p>Dominar React no es solo aprender una herramienta; es aprender un modelo mental para construir interfaces de usuario que ha definido la última década del desarrollo web.</p>',
        duration: 45,
      },
      {
        id: '3.2',
        title: 'Componentes, props y JSX',
        content:
          '<h2>Los Bloques de Construcción: Componentes, JSX y Props</h2><p>El corazón de React es el <strong>componente</strong>. Es la unidad fundamental de reutilización y composición. Para definir cómo se ve un componente, usamos <strong>JSX</strong>, y para pasarle datos, usamos <strong>props</strong>.</p><h3>1. JSX: JavaScript con Superpoderes</h3><p>JSX (JavaScript XML) es una extensión de la sintaxis de JavaScript que te permite escribir algo muy parecido a HTML directamente en tu código JavaScript. <strong>No es HTML</strong>; es "azúcar sintáctico" que se transforma (transpila) en llamadas a funciones de React.</p><pre><code class="language-jsx">// Esto que escribes en JSX...\\nconst miElemento = &lt;h1 className="saludo"&gt;Hola, Alberto&lt;/h1&gt;;\\n\\n// ...se convierte en esto por debajo:\\nconst miElementoJS = React.createElement(\'h1\', {className: \'saludo\'}, \'Hola, Alberto\');\\n</code></pre><p>JSX combina el poder expresivo de JavaScript con la sintaxis familiar de HTML. Puedes incrustar cualquier expresión de JavaScript dentro de las llaves <code>{}</code>.</p><pre><code class="language-jsx">const nombre = "Alberto";\\nconst elemento = &lt;h1&gt;Hola, {nombre.toUpperCase()}&lt;/h1&gt;; // Renderiza "Hola, ALBERTO"\\n</code></pre><h3>2. Componentes: Funciones que Devuelven UI</h3><p>En React moderno, un componente es simplemente una función de JavaScript que cumple dos reglas:</p><ol><li><strong>Su nombre debe empezar con mayúscula</strong> (p. ej., <code>MiComponente</code>). Esto es crucial para que React lo distinga de una etiqueta HTML normal.</li><li><strong>Debe devolver algo que React pueda renderizar</strong>, generalmente un bloque de JSX.</li></ol><pre><code class="language-jsx">function Saludo() {\\n  return &lt;h1&gt;¡Bienvenido a tu primer componente!&lt;/h1&gt;;\\n}\\n\\n// Para usarlo en otro componente:\\nfunction App() {\\n  return (\\n    &lt;div&gt;\\n      &lt;Saludo /&gt;\\n    &lt;/div&gt;\\n  );\\n}\\n</code></pre><p>La magia está en que puedes componer componentes dentro de otros, creando árboles complejos de UI a partir de piezas simples y reutilizables.</p><h3>3. Props: Pasando Datos a los Componentes</h3><p>Las <strong>props</strong> (abreviatura de "properties") son la forma de pasar datos desde un componente padre a un componente hijo. Son como los argumentos de una función. Las props son <strong>inmutables</strong>; un componente hijo nunca debe modificar las props que recibe.</p><pre><code class="language-jsx">// Componente hijo que recibe props\\nfunction SaludoPersonalizado(props) {\\n  // Las props llegan como un objeto\\n  return &lt;h1&gt;Hola, {props.nombre}&lt;/h1&gt;;\\n}\\n\\n// Componente padre que envía props\\nfunction App() {\\n  return (\\n    &lt;div&gt;\\n      &lt;SaludoPersonalizado nombre="Alberto" /&gt;\\n      &lt;SaludoPersonalizado nombre="María" /&gt;\\n    &lt;/div&gt;\\n  );\\n}\\n</code></pre><p>Este flujo de datos unidireccional (de padre a hijo) hace que las aplicaciones de React sean más predecibles y fáciles de depurar. Entender este trío (Componentes, JSX, Props) es el primer gran paso para pensar en React.</p>',
        duration: 90,
      },
      {
        id: '3.3',
        title: 'State y Ciclo de Vida (Hooks)',
        content:
          '<h2>La Memoria de los Componentes: State y Hooks</h2><p>Los componentes que hemos visto hasta ahora son estáticos. Reciben props y renderizan una UI. Pero, ¿qué pasa cuando un componente necesita recordar información y reaccionar a eventos a lo largo del tiempo? Para eso, React nos da el concepto de <strong>estado (state)</strong>.</p><h3>1. El Problema: Las Variables Normales no Funcionan</h3><p>Podrías pensar en usar una variable normal para almacenar un valor que cambia, como un contador.</p><pre><code class="language-jsx">function ContadorErroneo() {\\n  let contador = 0;\\n\\n  function handleClick() {\\n    contador = contador + 1;\\n    // ¡La UI no se actualiza! React no sabe que este cambio es importante.\\n    console.log(contador); // La consola muestra 1, 2, 3... pero la pantalla no.\\n  }\\n\\n  return (\\n    &lt;div&gt;\\n      &lt;p&gt;Has hecho clic {contador} veces&lt;/p&gt;\\n      &lt;button onClick={handleClick}&gt;Haz clic&lt;/button&gt;\\n    &lt;/div&gt;\\n  );\\n}\\n</code></pre><p>El problema es que React no sabe que tiene que volver a renderizar el componente cuando una variable local cambia. React solo renderiza de nuevo cuando cambian las props o el <strong>estado</strong>.</p><h3>2. La Solución: El Hook `useState`</h3><p>Los <strong>Hooks</strong> son funciones especiales (siempre empiezan con `use`) que te permiten "engancharte" a las características de React desde tus componentes de función. El hook más fundamental es <strong>`useState`</strong>.</p><p>`useState` nos permite añadir una "variable de estado" a un componente.</p><pre><code class="language-jsx">import { useState } from \'react\';\\n\\nfunction ContadorCorrecto() {\\n  // 1. Declarar una variable de estado\\n  const [contador, setContador] = useState(0); // 0 es el valor inicial\\n\\n  // `useState` devuelve un array con dos elementos:\\n  //   - `contador`: El valor actual del estado.\\n  //   - `setContador`: Una función para actualizar ese estado.\\n\\n  function handleClick() {\\n    // 2. Usar la función de actualización\\n    setContador(contador + 1);\\n    // ¡Al llamar a setContador, le decimos a React que este componente necesita ser renderizado de nuevo!\\n  }\\n\\n  return (\\n    &lt;div&gt;\\n      &lt;p&gt;Has hecho clic {contador} veces&lt;/p&gt;\\n      &lt;button onClick={handleClick}&gt;Haz clic&lt;/button&gt;\\n    &lt;/div&gt;\\n  );\\n}\\n</code></pre><h3>Reglas de los Hooks</h3><p>Los Hooks tienen dos reglas estrictas:</p><ol><li><strong>Solo llama a los Hooks en el nivel superior de tus componentes de función.</strong> No los llames dentro de bucles, condicionales o funciones anidadas.</li><li><strong>Solo llama a los Hooks desde componentes de función de React.</strong> No los llames desde funciones de JavaScript normales.</li></ol><p>El `state` es la memoria de un componente. Es cualquier dato que cambia con el tiempo debido a la interacción del usuario o eventos de la red. Cada vez que actualizas el estado con su función `set`, React se encarga de volver a renderizar tu componente y sus hijos, manteniendo la UI perfectamente sincronizada con los datos.</p>',
        duration: 90,
      },
      {
        id: '3.4',
        title: 'Enrutamiento en Next.js (App Router)',
        content:
          '<h2>Navegando en Aplicaciones Modernas: Enrutamiento en Next.js</h2><p>En una aplicación web tradicional, cada URL que visitas descarga un nuevo archivo HTML del servidor. En una <strong>Aplicación de Página Única (SPA)</strong>, como las que se construyen con React, la experiencia es más fluida. La página inicial se carga una vez, y la navegación a otras "páginas" ocurre en el cliente, cambiando la UI dinámicamente sin recargar la página completa. Esto se logra a través del <strong>enrutamiento del lado del cliente</strong>.</p><h3>El App Router de Next.js: Enrutamiento Basado en Archivos</h3><p>Next.js lleva el enrutamiento a otro nivel con un sistema potente e intuitivo basado en el sistema de archivos, conocido como <strong>App Router</strong>. En lugar de configurar rutas en un archivo de código, la estructura de tus carpetas dentro del directorio <code>src/app</code> define automáticamente las rutas de tu aplicación.</p><h4>Principios Básicos:</h4><ul><li><strong>Cada Carpeta es una Ruta:</strong> Una carpeta dentro de <code>src/app</code> crea un nuevo segmento de URL. Por ejemplo, <code>src/app/dashboard/settings/</code> se mapea a la URL <code>/dashboard/settings</code>.</li><li><strong>El Archivo `page.tsx`:</strong> Para que un segmento de ruta sea públicamente accesible, debe contener un archivo <code>page.tsx</code>. Este archivo exporta por defecto el componente de React que se renderizará para esa ruta.</li><li><strong>Rutas Anidadas:</strong> Al anidar carpetas, creas rutas anidadas. <code>src/app/products/[productId]/page.tsx</code> define una ruta dinámica donde <code>[productId]</code> es un parámetro.</li><li><strong>Layouts Compartidos (`layout.tsx`):</strong> Puedes definir un archivo <code>layout.tsx</code> dentro de una carpeta. Este layout envolverá a la página de ese segmento (<code>page.tsx</code>) y a todas las páginas de sus sub-rutas. Es perfecto para barras laterales, encabezados y pies de página compartidos.</li></ul><pre><code class="language-text">src/app/\\n├── layout.tsx       # Layout raíz (afecta a toda la app)\\n├── page.tsx         # Página de inicio (/)\\n└── dashboard/\\n    ├── layout.tsx   # Layout para todas las rutas de dashboard\\n    ├── page.tsx     # Página de /dashboard\\n    └── settings/\\n        └── page.tsx # Página de /dashboard/settings\\n</code></pre><h3>Componentes de Servidor vs. Componentes de Cliente</h3><p>El App Router de Next.js introduce una distinción clave: por defecto, todos los componentes dentro de <code>app</code> son <strong>Componentes de Servidor (Server Components)</strong>. Esto significa que se renderizan en el servidor y solo se envía HTML al cliente, reduciendo la cantidad de JavaScript necesario. Si un componente necesita interactividad (como usar <code>useState</code> o <code>useEffect</code>), debes marcarlo explícitamente con la directiva <code>"use client";</code> al principio del archivo. Este modelo híbrido te da lo mejor de ambos mundos: el rendimiento del renderizado en servidor y la interactividad rica del cliente cuando es necesario.</p><p>Dominar el enrutamiento basado en archivos de Next.js te permite construir aplicaciones complejas y optimizadas de manera estructurada y predecible, gestionando layouts y vistas de forma intuitiva.</p>',
        duration: 75,
      },
      {
        id: '3.5',
        title: 'Efectos Secundarios y Hooks Personalizados',
        content:
          '<h2>Más Allá del Renderizado: Efectos Secundarios con `useEffect`</h2><p>Los componentes de React están diseñados para una tarea principal: calcular y renderizar UI a partir de props y estado. Pero, ¿qué pasa cuando tu componente necesita interactuar con el "mundo exterior"? Por ejemplo, hacer una petición a una API, suscribirse a eventos, o manipular el DOM directamente. Estas operaciones se llaman <strong>efectos secundarios (side effects)</strong>.</p><p>El Hook <strong>`useEffect`</strong> es la herramienta de React para manejar estos efectos secundarios de una manera controlada y predecible dentro de tus componentes de función.</p><h3>El Hook `useEffect`</h3><p>Imagina que quieres obtener datos de un perfil de usuario cuando el componente se monta por primera vez.</p><pre><code class="language-jsx">import { useState, useEffect } from \'react\';\\n\\nfunction PerfilDeUsuario({ userId }) {\\n  const [usuario, setUsuario] = useState(null);\\n\\n  useEffect(() => {\\n    // Esta función (el "efecto") se ejecutará DESPUÉS de que el componente se renderice.\\n    console.log("El efecto se está ejecutando...");\\n    fetch(`https://api.example.com/users/${userId}`)\\n      .then(res => res.json())\\n      .then(data => setUsuario(data));\\n\\n  }, [userId]); // El array de dependencias\\n\\n  if (!usuario) {\\n    return &lt;div&gt;Cargando...&lt;/div&gt;\\n  }\\n\\n  return &lt;h1&gt;{usuario.nombre}&lt;/h1&gt;\\n}\\n</code></pre><h4>El Array de Dependencias: Controlando Cuándo se Ejecuta el Efecto</h4><p>El segundo argumento de `useEffect` es crucial. Es un array de dependencias que le dice a React cuándo debe volver a ejecutar el efecto.</p><ul><li><strong>Array vacío <code>[]</code>:</strong> El efecto se ejecuta <strong>solo una vez</strong>, después del primer renderizado. Perfecto para inicializaciones o peticiones de datos que no cambian.</li><li><strong>Con variables <code>[userId]</code>:</strong> El efecto se ejecuta la primera vez, y luego <strong>solo si el valor de <code>userId</code> ha cambiado</strong> desde el último renderizado. Esto es clave para evitar peticiones de red innecesarias.</li><li><strong>Sin array (no recomendado):</strong> Si omites el segundo argumento, el efecto se ejecutará <strong>después de cada renderizado</strong>, lo que puede llevar a bucles infinitos y problemas de rendimiento.</li></ul><h3>Limpieza de Efectos</h3><p>Algunos efectos necesitan "limpieza". Por ejemplo, si te suscribes a un evento, debes desuscribirte cuando el componente se desmonte para evitar fugas de memoria. Para esto, puedes devolver una función desde tu efecto.</p><pre><code class="language-jsx">useEffect(() => {\\n  const handleResize = () => console.log("Ventana redimensionada");\\n  window.addEventListener(\'resize\', handleResize);\\n\\n  // Esta función de limpieza se ejecuta cuando el componente se va a desmontar\\n  return () => {\\n    window.removeEventListener(\'resize\', handleResize);\\n  };\\n}, []);\\n</code></pre><h3>Hooks Personalizados: Reutilizando Lógica</h3><p>Cuando te encuentras repitiendo la misma lógica de estado y efectos en varios componentes, es hora de crear un <strong>Hook personalizado (Custom Hook)</strong>. Un Hook personalizado es simplemente una función de JavaScript cuyo nombre empieza por `use` y que puede llamar a otros Hooks.</p><pre><code class="language-jsx">// useUserData.js (Nuestro Hook Personalizado)\\nimport { useState, useEffect } from \'react\';\\n\\nexport function useUserData(userId) {\\n  const [usuario, setUsuario] = useState(null);\\n  const [cargando, setCargando] = useState(true);\\n\\n  useEffect(() => {\\n    setCargando(true);\\n    fetch(`https://api.example.com/users/${userId}`)\\n      .then(res => res.json())\\n      .then(data => setUsuario(data))\\n      .finally(() => setCargando(false));\\n  }, [userId]);\\n\\n  return { usuario, cargando };\\n}\\n\\n// PerfilDeUsuario.js (Usando nuestro Hook)\\nimport { useUserData } from \'./useUserData\';\\n\\nfunction PerfilDeUsuario({ userId }) {\\n  const { usuario, cargando } = useUserData(userId);\\n\\n  if (cargando) return &lt;div&gt;Cargando...&lt;/div&gt;;\\n  return &lt;h1&gt;{usuario.nombre}&lt;/h1&gt;\\n}\\n</code></pre><p>Los Hooks personalizados son una de las características más poderosas de React para crear código limpio, reutilizable y fácil de mantener.</p>',
        duration: 120,
      },
      {
        id: '3.6',
        title: 'Manejo Avanzado de Formularios',
        content:
          '<h2>La Interfaz entre Usuario y Aplicación: Formularios en React</h2><p>Los formularios son una parte esencial de casi cualquier aplicación web. En React, el manejo de formularios puede parecer complicado al principio, pero se basa en un patrón poderoso y predecible llamado <strong>componentes controlados (controlled components)</strong>.</p><h3>El Patrón de Componentes Controlados</h3><p>La idea es simple: el estado de React se convierte en la "única fuente de verdad" para el formulario. En lugar de que el DOM maneje el estado del input (lo que escribes), lo guardamos en el estado de nuestro componente.</p><p>El flujo es el siguiente:</p><ol><li>Creamos una variable de estado con <code>useState</code> para cada campo del formulario.</li><li>El valor del input en el JSX se establece directamente desde esa variable de estado (<code>value={miEstado}</code>).</li><li>Usamos el evento <code>onChange</code> del input para llamar a la función <code>set</code> del estado, actualizándolo con el nuevo valor cada vez que el usuario escribe.</li></ol><pre><code class="language-jsx">import { useState } from \'react\';\\n\\nfunction FormularioNombre() {\\n  // 1. Estado como fuente de verdad\\n  const [nombre, setNombre] = useState(\'\');\\n\\n  function handleChange(event) {\\n    // 3. Actualizar el estado en cada cambio\\n    setNombre(event.target.value);\\n  }\\n\\n  function handleSubmit(event) {\\n    event.preventDefault(); // Prevenir recarga de la página\\n    alert(`Hola, ${nombre}!`);\\n  }\\n\\n  return (\\n    &lt;form onSubmit={handleSubmit}&gt;\\n      &lt;label&gt;\\n        Nombre:\\n        &lt;input \\n          type="text" \\n          // 2. El valor del input está "controlado" por el estado\\n          value={nombre} \\n          onChange={handleChange} \\n        /&gt;\\n      &lt;/label&gt;\\n      &lt;button type="submit"&gt;Enviar&lt;/button&gt;\\n    &lt;/form&gt;\\n  );\\n}\\n</code></pre><p>Este patrón nos da un control total. Podemos validar el input en tiempo real, deshabilitar el botón de envío si el formulario no es válido, o formatear el valor mientras el usuario escribe.</p><h3>Manejando Múltiples Inputs</h3><p>Para formularios más complejos, no quieres una función `handleChange` para cada input. Puedes usar el atributo <code>name</code> de los inputs para manejar todos los campos con una sola función y un estado que sea un objeto.</p><pre><code class="language-jsx">function FormularioCompleto() {\\n  const [formData, setFormData] = useState({\\n    nombre: \'\',\\n    email: \'\'\\n  });\\n\\n  function handleChange(event) {\\n    const { name, value } = event.target;\\n    setFormData(prevFormData => ({\\n      ...prevFormData,\\n      [name]: value\\n    }));\\n  }\\n\\n  // ...\\n}\\n</code></pre><h3>Librerías de Formularios</h3><p>Para formularios muy grandes y complejos con validaciones, gestión de errores y estado de envío, escribir todo a mano puede ser tedioso. Es aquí donde brillan librerías como <strong>React Hook Form</strong> y <strong>Formik</strong>. Estas librerías abstraen gran parte de la lógica repetitiva, optimizan el rendimiento (evitando re-renderizados innecesarios) y facilitan enormemente las validaciones. En un entorno profesional, es muy común utilizar una de estas librerías para manejar los formularios.</p>',
        duration: 90,
      },
      {
        id: '3.7',
        title: 'Introducción a Vue.js',
        content:
          '<h2>Una Alternativa Progresiva: Introducción a Vue.js</h2><p>Vue.js es otro framework de JavaScript extremadamente popular para construir interfaces de usuario. A menudo se le considera más fácil de aprender que React o Angular, especialmente para desarrolladores que vienen de un entorno de HTML y CSS más tradicional. Su lema es ser un "Framework Progresivo", lo que significa que puedes adoptarlo gradualmente, desde una simple librería para añadir interactividad a una página hasta un framework completo para una SPA compleja.</p><h3>Características Principales:</h3><ul><li><strong>Sintaxis Basada en Plantillas:</strong> A diferencia de JSX, Vue utiliza plantillas que se asemejan más al HTML clásico, separando la lógica (script) de la estructura (template).</li><li><strong>Reactividad:</strong> El sistema de reactividad de Vue es muy potente. Cuando un dato cambia, la UI se actualiza automáticamente sin necesidad de funciones `set` explícitas como en React.</li><li><strong>Componentes de un Solo Archivo (Single File Components):</strong> Vue popularizó la idea de encapsular el HTML, CSS y JavaScript de un componente en un único archivo <code>.vue</code>, lo que promueve una excelente organización.</li></ul><p>Vue es una opción fantástica, conocida por su excelente documentación y una curva de aprendizaje más suave.</p>',
        duration: 60,
      },
      {
        id: '3.8',
        title: 'Introducción a Angular',
        content:
          '<h2>El Framework Todo Incluido: Introducción a Angular</h2><p>Angular (desarrollado y mantenido por Google) es un framework completo y opinado para construir aplicaciones web a gran escala. A diferencia de React (una librería) o Vue (un framework progresivo), Angular es una "plataforma" que viene con todo lo que necesitas para construir una aplicación empresarial: enrutamiento, gestión de estado, cliente HTTP, manejo de formularios, etc., todo integrado.</p><h3>Características Principales:</h3><ul><li><strong>Basado en TypeScript:</strong> Angular está escrito completamente en TypeScript y lo impone como el lenguaje de desarrollo, lo que aporta robustez y escalabilidad al código.</li><li><strong>Arquitectura Opinada:</strong> Angular tiene una estructura muy definida basada en Módulos, Componentes, Servicios e Inyección de Dependencias. Esto puede tener una curva de aprendizaje más pronunciada, pero resulta en aplicaciones muy consistentes y mantenibles en equipos grandes.</li><li><strong>Inyección de Dependencias:</strong> Es un patrón de diseño central en Angular que facilita la gestión y el testeo de las diferentes partes de la aplicación.</li></ul><p>Angular es una opción muy potente para proyectos grandes y de nivel empresarial donde la consistencia, la escalabilidad y la mantenibilidad a largo plazo son las máximas prioridades.</p>',
        duration: 60,
      },
    ],
    project: {
      title: 'App de notas con React',
      description:
        'Desarrolla una aplicación de notas completa utilizando React, manejando estado, componentes y routing.',
    },
    quizId: 'quiz_3',
  },
  {
    id: '4',
    title: 'MÓDULO 4: Integración de IA con Genkit y Next.js',
    objective: 'Aprender a construir e integrar flujos de IA en una aplicación web moderna.',
    classes: [
      {
        id: '4.1',
        title: 'Introducción a Genkit y los Flujos de IA',
        content:
          '<h2>Potenciando tu App con IA: Introducción a Genkit</h2><p>Has aprendido a construir interfaces de usuario robustas con React y Next.js. Ahora, es momento de llevar tus aplicaciones al siguiente nivel integrando capacidades de Inteligencia Artificial. En este módulo, usaremos <strong>Genkit</strong>, un framework de Google diseñado para simplificar la creación y despliegue de aplicaciones de IA.</p><h3>¿Qué es Genkit?</h3><p>Genkit es un framework de código abierto que proporciona una estructura y herramientas para construir flujos de IA de manera organizada y eficiente. En lugar de hacer llamadas directas y desordenadas a las APIs de los modelos de lenguaje, Genkit te permite:</p><ul><li><strong>Definir Flujos (Flows):</strong> Encapsular la lógica de una tarea de IA en una unidad cohesiva y reutilizable. Un flujo puede implicar llamar a un modelo, procesar su salida y llamar a otras herramientas.</li><li><strong>Gestionar Prompts:</strong> Escribir y mantener los prompts (las instrucciones que le das a la IA) de forma estructurada y versionada.</li><li><strong>Integrar Herramientas (Tools):</strong> Darle a tu IA la capacidad de interactuar con otros sistemas, como bases de datos o APIs externas.</li><li><strong>Observabilidad:</strong> Monitorear y depurar tus flujos de IA, viendo exactamente qué prompts se enviaron y qué respuestas se recibieron.</li></ul><h3>El Corazón de Genkit: El Flujo (Flow)</h3><p>Un flujo es el concepto central. Es una función que defines para realizar una tarea específica. Dentro de nuestra aplicación, ya tenemos varios flujos, como `generateQuizFlow` o `textToSpeechFlow`. Revisemos la estructura de un flujo simple:</p><pre><code class="language-typescript">// src/ai/flows/summarize-lesson.ts\\n\\n\\\'use server\\\';\\n\\nimport { ai } from \\\'@/ai/genkit\\\';\\nimport { z } from \\\'genkit\\\';\\n\\n// 1. Definir el esquema de entrada con Zod\\nconst SummarizeLessonInputSchema = z.object({\\n  lessonContent: z.string(),\\n});\\n\\n// 2. Definir el esquema de salida con Zod\\nconst SummarizeLessonOutputSchema = z.object({\\n  summary: z.string(),\\n});\\n\\n// 3. Crear y exportar una función contenedora\\nexport async function summarizeLesson(input) {\\n  return summarizeLessonFlow(input);\\n}\\n\\n// 4. Definir el prompt para la IA\\nconst prompt = ai.definePrompt({\\n  name: \\\'summarizeLessonPrompt\\\',\\n  input: { schema: SummarizeLessonInputSchema },\\n  output: { schema: SummarizeLessonOutputSchema },\\n  prompt: `Genera un resumen conciso del siguiente contenido de la lección:\\n\\n{{lessonContent}}`,\\n});\\n\\n// 5. Definir el flujo que orquesta todo\\nconst summarizeLessonFlow = ai.defineFlow(\\n  {\\n    name: \\\'summarizeLessonFlow\\\',\\n    inputSchema: SummarizeLessonInputSchema,\\n    outputSchema: SummarizeLessonOutputSchema,\\n  },\\n  async input => {\\n    const { output } = await prompt(input);\\n    return output;\\n  }\\n);\\n</code></pre><p>En esta lección, hemos visto cómo Genkit nos proporciona una forma estructurada de añadir IA a nuestras aplicaciones. En las siguientes clases, construiremos sobre estos conceptos para crear funcionalidades aún más impresionantes.</p>',
        duration: 60,
      },
      {
        id: '4.2',
        title: 'Output Estructurado con Zod y JSON',
        content: '<h2>Hablando el Mismo Idioma: Output Estructurado con IA</h2><p>Uno de los mayores desafíos al trabajar con Modelos de Lenguaje Grandes (LLMs) es que, por naturaleza, producen texto no estructurado. Sin embargo, para que nuestras aplicaciones puedan usar la respuesta de una IA de manera fiable, a menudo necesitamos los datos en un formato específico, como JSON. Aquí es donde la combinación de <strong>Genkit</strong> y <strong>Zod</strong> se vuelve increíblemente poderosa.</p><h3>El Problema: Respuestas de Texto Impredecibles</h3><p>Imagina que le pides a una IA que genere un quiz. Si simplemente le pides "genera 5 preguntas de opción múltiple", podría devolverte el texto en una infinidad de formatos. Procesar eso en tu aplicación sería una pesadilla, llena de expresiones regulares y lógica frágil.</p><h3>La Solución: Forzar el Modo JSON con un Esquema de Salida</h3><p>Genkit tiene una funcionalidad clave: si defines un <code>outputSchema</code> usando Zod en tu prompt, Genkit instruirá al modelo de IA para que responda <strong>obligatoriamente en un formato JSON</strong> que coincida con ese esquema. Esto transforma una respuesta de texto libre en datos estructurados y predecibles.</p><p>Analicemos nuestro flujo de generación de quizzes (`src/ai/flows/generate-quiz.ts`):</p><pre><code class="language-typescript">// 1. Definimos el esquema de salida con Zod\\nconst GenerateQuizOutputSchema = z.object({\\n  quiz: z.array(\\n    z.object({\\n      question: z.string().describe(\\\'La pregunta del quiz.\\\'),\\n      answers: z.array(z.string()).describe(\\\'Las posibles respuestas.\\\'),\\n      correctAnswerIndex: z.number().describe(\\\'El índice de la respuesta correcta.\\\'),\\n    })\\n  ).describe(\\\'El quiz generado.\\\'),\\n});\\n</code></pre><p>Este esquema le dice a la IA exactamente lo que esperamos: un objeto con una propiedad `quiz`, que es un array de objetos. Cada uno de estos objetos debe tener una `question` (string), un array de `answers` (strings) y un `correctAnswerIndex` (number).</p><pre><code class="language-typescript">// 2. Usamos el esquema en nuestro prompt\\nconst prompt = ai.definePrompt({\\n  name: \\\'generateQuizPrompt\\\',\\n  input: { schema: GenerateQuizInputSchema },\\n  output: { schema: GenerateQuizOutputSchema }, // ¡Aquí está la magia!\\n  prompt: `You are an expert quiz generator... YOUR RESPONSE MUST BE IN VALID JSON FORMAT...`,\\n});\\n</code></pre><p>Al pasar `GenerateQuizOutputSchema` al campo `output.schema`, Genkit hace dos cosas:</p><ol><li>Le pasa la descripción del esquema al modelo como parte de sus instrucciones, guiándolo para que genere la estructura correcta.</li><li>Configura la llamada a la API del modelo para que se active el **modo JSON**, lo que obliga a que la respuesta sea un JSON válido.</li></ol><p>Además, reforzamos esto en el propio prompt con la instrucción `YOUR RESPONSE MUST BE IN VALID JSON FORMAT`. Esta redundancia ayuda a garantizar el éxito.</p><h3>El Resultado: Datos Fiables</h3><p>Gracias a este patrón, cuando llamamos a nuestro flujo `generateQuiz`, no recibimos una cadena de texto que tenemos que interpretar, sino un objeto JavaScript perfectamente tipado y listo para ser utilizado en nuestra aplicación React. Esto elimina una enorme fuente de errores y hace que nuestro código sea mucho más robusto y fácil de mantener.</p><p>Dominar esta técnica es esencial para pasar de simples chatbots a construir aplicaciones complejas y fiables impulsadas por IA.</p>',
        duration: 75,
      },
      {
        id: '4.3',
        title: 'Búsqueda Semántica con Modelos de Lenguaje',
        content: '<h2>Más Allá de las Palabras Clave: Búsqueda Semántica</h2><p>Has interactuado con la página de "Buscador del Curso". A diferencia de una búsqueda tradicional que busca coincidencias exactas de palabras clave, la nuestra es mucho más inteligente. Utiliza una técnica poderosa llamada <strong>Búsqueda Semántica</strong>, que se basa en la capacidad del modelo de lenguaje para comprender el *significado* y el *contexto* de una consulta.</p><h3>¿Cómo Funciona?</h3><p>El enfoque, a menudo relacionado con un patrón llamado <strong>Generación Aumentada por Recuperación (RAG)</strong>, es conceptualmente simple pero muy potente:</p><ol><li><strong>Contexto Masivo:</strong> En lugar de esperar que el modelo "sepa" el contenido de nuestro curso, le proporcionamos todo el material como parte del contexto en cada consulta. En el archivo <code>src/app/(main)/search/page.tsx</code>, pre-procesamos todo el `courseData` en una única y gigantesca cadena de texto.</li><li><strong>Consulta Inteligente:</strong> Cuando haces una pregunta como "¿qué es el box model?", no solo le pasamos esa pregunta al modelo. Le pasamos la pregunta <strong>y</strong> todo el contenido del curso.</li><li><strong>Prompt de "Motor de Búsqueda":</strong> El prompt en `src/ai/flows/search-course.ts` no le pide al modelo que *responda* la pregunta, sino que *actúe como un motor de búsqueda experto*. Le pedimos que analice la consulta y que encuentre y extraiga los fragmentos de texto (snippets) más relevantes del contexto que le proporcionamos.</li></ol><p>Revisemos el prompt clave:</p><pre><code class="language-typescript">prompt: `You are an expert search engine for an online web development course. Your task is to analyze the user\\\'s query and find the most relevant classes and content snippets from the provided course material.\\n\\nReturn a list of the most relevant results. For each result, provide the module ID, class ID, class title, and a concise snippet from the content that directly addresses the user\\\'s query.\\n\\nUser Query:\\n"{{{query}}}"\\n\\nFull Course Content:\\n---\\n{{{courseContent}}}\\n---`</code></pre><h3>El Poder de la Comprensión</h3><p>Este método funciona porque el LLM no está simplemente buscando palabras. Está usando su comprensión del lenguaje para encontrar las secciones que *semánticamente* se relacionan con tu consulta, incluso si no usas las mismas palabras exactas que están en el texto. Además, al pedirle que devuelva los `moduleId` y `classId` junto con el snippet, podemos construir enlaces directos a las lecciones relevantes, creando una experiencia de usuario fluida y útil.</p><p>Esta técnica es la base para crear chatbots de ayuda, sistemas de preguntas y respuestas sobre documentos, y cualquier aplicación que necesite "razonar" sobre un cuerpo de conocimiento específico.</p>',
        duration: 75,
      }
    ],
    project: {
      title: 'Chatbot de Ayuda para el Curso',
      description: 'Crear un chatbot que pueda responder preguntas sobre el contenido del curso utilizando un flujo de Genkit y búsqueda semántica.',
    },
    quizId: 'quiz_4',
  },
  {
    id: '5',
    title: 'MÓDULO 5: Introducción a Web3 y Blockchain',
    objective: 'Comprender los conceptos fundamentales de la web descentralizada y cómo interactuar con ella.',
    classes: [
      {
        id: '5.1',
        title: '¿Qué es Web3 y la Blockchain?',
        content: '',
        duration: 60,
      },
      {
        id: '5.2',
        title: 'Criptomonedas y Wallets',
        content: '',
        duration: 60,
      },
      {
        id: '5.3',
        title: 'Smart Contracts e Interacción con la Blockchain',
        content: '',
        duration: 90,
      },
      {
        id: '5.4',
        title: 'Construyendo tu Primera dApp (Aplicación Descentralizada)',
        content: '',
        duration: 120,
      },
    ],
    project: {
      title: 'Lector de Balance de Wallet',
      description: 'Construir una aplicación Next.js simple que se conecte a una wallet de criptomonedas y muestre su balance.',
    },
    quizId: 'quiz_5',
  },
];

    


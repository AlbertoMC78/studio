
export interface CourseClass {
  id: string;
  title: string;
  content: string;
  duration: number; // in minutes
}

export interface CourseModule {
  id: string;
  title:string;
  objective: string;
  classes: CourseClass[];
  project: {
    title: string;
    description: string;
  };
  quizId?: string;
}

export const courseData: CourseModule[] = [
  {
    id: '1',
    title: 'MÓDULO 1: Fundamentos de la Web (HTML, CSS, Git)',
    objective:
      'Aprender cómo funciona la web, crear estructuras con HTML y estilos con CSS',
    classes: [
      {
        id: '1.1',
        title: '¿Cómo funciona la Web?',
        content:
          '<h2>El Viaje de una Página Web: Del Clic a la Pantalla</h2>\n<p>Cada vez que visitas un sitio web, desencadenas una serie de eventos rapidísimos y complejos a través de una red global. La arquitectura que lo hace posible se conoce como el <strong>modelo Cliente-Servidor</strong>. Es la columna vertebral de la World Wide Web.</p>\n\n<h3>1. Los Actores Principales</h3>\n<ul>\n  <li><strong>El Cliente (Tu Navegador):</strong> Es el software en tu dispositivo (Chrome, Firefox, Safari) que actúa como tu agente en la web. Su trabajo es solicitar, recibir e interpretar (renderizar) la información para que puedas verla y interactuar con ella.</li>\n  <li><strong>El Servidor:</strong> Es un ordenador potente, siempre encendido y conectado a internet, cuyo propósito es "servir" contenido cuando un cliente lo solicita. Almacena los archivos (HTML, CSS, JavaScript, imágenes), ejecuta lógica de negocio y se conecta a bases de datos.</li>\n</ul>\n\n<h3>2. El Protocolo de Comunicación: HTTP/S</h3>\n<p>Cliente y servidor necesitan un lenguaje común para entenderse. Este lenguaje es el <strong>Protocolo de Transferencia de Hipertexto (HTTP)</strong>. Su versión segura, <strong>HTTPS</strong>, encripta la comunicación, lo cual es el estándar hoy en día.</p>\n<ul>\n    <li><strong>Petición (Request):</strong> El cliente envía una petición HTTP al servidor. Por ejemplo: <code>GET /index.html</code>, que significa "dame el archivo index.html". Otros métodos comunes son <code>POST</code> (para enviar datos), <code>PUT</code> (para actualizar) y <code>DELETE</code> (para borrar). La petición también incluye cabeceras (headers) con metadatos, como el tipo de navegador que usas.</li>\n    <li><strong>Respuesta (Response):</strong> El servidor procesa la petición y devuelve una respuesta HTTP, que incluye un <strong>código de estado</strong> (como <code>200 OK</code> si todo fue bien, o <code>404 Not Found</code> si no encontró el recurso) y el contenido solicitado (el archivo HTML, por ejemplo).</li>\n</ul>\n\n<h3>3. Las Direcciones de la Web: IP y DNS</h3>\n<p>Para que tu navegador sepa a qué servidor enviar la petición, necesita su dirección. En internet, las direcciones son numéricas, llamadas <strong>direcciones IP</strong> (ej., <code>172.217.16.142</code>).</p>\n<p>Como recordar números es difícil para los humanos, usamos nombres de dominio (ej., <code>google.com</code>). El <strong>Sistema de Nombres de Dominio (DNS)</strong> actúa como la agenda telefónica de internet, traduciendo los nombres de dominio que escribimos a la dirección IP del servidor correspondiente.</p>\n\n<h3>4. El Proceso Completo (Paso a Paso)</h3>\n<ol>\n  <li><strong>Escribes la URL:</strong> Ingresas <code>https://www.ejemplo.com</code> en tu navegador y presionas Enter.</li>\n  <li><strong>Traducción DNS:</strong> Tu navegador pregunta a un servidor DNS: "¿Cuál es la IP de <code>www.ejemplo.com</code>?". El DNS responde con la dirección IP del servidor.</li>\n  <li><strong>Petición HTTP/S:</strong> Tu navegador establece una conexión con el servidor en esa IP y le envía una petición HTTP/S pidiendo la página principal.</li>\n  <li><strong>Procesamiento del Servidor:</strong> El servidor recibe la petición. Busca el archivo HTML solicitado. Si es una página dinámica (ej., un perfil de red social), puede que necesite consultar una base de datos y construir el HTML sobre la marcha.</li>\n  <li><strong>Respuesta del Servidor:</strong> El servidor envía el archivo HTML de vuelta a tu navegador como parte de la respuesta HTTP/S.</li>\n  <li><strong>Renderizado (Fase 1 - HTML):</strong> El navegador comienza a leer el HTML. Entiende la estructura: aquí va un título, aquí un párrafo, aquí una imagen.</li>\n  <li><strong>Peticiones Adicionales:</strong> Mientras lee el HTML, el navegador encuentra referencias a otros archivos, como hojas de estilo CSS (<code>&lt;link rel="stylesheet" href="style.css"&gt;</code>) y scripts de JavaScript (<code>&lt;script src="app.js"&gt;&lt;/script&gt;</code>). Realiza peticiones HTTP/S adicionales para cada uno de estos archivos.</li>\n  <li><strong>Renderizado (Fase 2 - CSS y JS):</strong> A medida que llegan los archivos CSS y JavaScript, el navegador los aplica. El CSS le da estilo y apariencia visual a la estructura HTML. El JavaScript añade interactividad, como animaciones, validación de formularios o la capacidad de cargar más contenido sin recargar la página.</li>\n</ol>\n<p>Este ciclo completo, desde la petición inicial hasta que la página es completamente visible e interactiva, ocurre en cuestión de segundos o incluso milisegundos, gracias a la eficiencia de esta arquitectura fundamental.</p>\n<hr/>\n<h3>Recursos Complementarios</h3>\n<h4>Videos Recomendados</h4>\n<ul>\n    <li><strong>(Español) ¿Cómo funciona Internet?</strong> - Un excelente resumen visual de Platzi: <a href="https://www.youtube.com/watch?v=JExO2i-QW4A" target="_blank" rel="noopener noreferrer">Ver en YouTube</a></li>\n    <li><strong>(Inglés) How the Web Works: A Primer for Newcomers to Web Development</strong> - Una explicación clara y concisa de MDN: <a href="https://www.youtube.com/watch?v=hJHvdBlSxug" target="_blank" rel="noopener noreferrer">Ver en YouTube</a></li>\n</ul>\n<h4>Lecturas Oficiales</h4>\n<ul>\n    <li><strong>MDN Web Docs: ¿Cómo funciona la web?</strong> - La documentación de referencia para desarrolladores: <a href="https://developer.mozilla.org/es/docs/Learn/Getting_started_with_the_web/How_the_Web_works" target="_blank" rel="noopener noreferrer">Leer artículo</a></li>\n</ul>',
        duration: 30,
      },
      {
        id: '1.2',
        title: 'HTML básico: etiquetas, listas, tablas, enlaces',
        content:
          '<h2>Los Cimientos de la Web: Estructura con HTML</h2>\n<p>HTML (HyperText Markup Language) no es un lenguaje de programación; es un <strong>lenguaje de marcado</strong>. Su única función es describir y estructurar el contenido de una página web. Le dice al navegador qué es un título, qué es un párrafo, dónde va una imagen, etc.</p>\n\n<h3>1. La Anatomía de una Etiqueta HTML</h3>\n<p>Casi todo en HTML está compuesto por <strong>elementos</strong>, que generalmente consisten en una etiqueta de apertura y una de cierre, envolviendo el contenido.</p>\n<pre><code class="language-html">&lt;p&gt;Este es el contenido de un párrafo.&lt;/p&gt;\n&lt;!--  |   |                       |  --&gt;\n&lt;!--  1   2                       3  --&gt;</code></pre>\n<ol>\n  <li><strong>Etiqueta de apertura:</strong> <code>&lt;p&gt;</code>. Indica el inicio de un elemento.</li>\n  <li><strong>Contenido:</strong> El texto o los otros elementos que van dentro.</li>\n  <li><strong>Etiqueta de cierre:</strong> <code>&lt;/p&gt;</code>. Igual que la de apertura, pero con una barra inclinada (<code>/</code>). Indica el final del elemento.</li>\n</ol>\n<p>Algunos elementos son "vacíos" o "auto-cerrados", lo que significa que no tienen contenido ni etiqueta de cierre, como la etiqueta de imagen <code>&lt;img&gt;</code> o la de salto de línea <code>&lt;br&gt;</code>.</p>\n\n<h3>2. Estructura Básica de un Documento HTML</h3>\n<p>Todo archivo <code>.html</code> sigue una estructura fundamental:</p>\n<pre><code class="language-html">&lt;!DOCTYPE html&gt;\n&lt;html lang="es"&gt;\n  &lt;head&gt;\n    &lt;meta charset="UTF-8"&gt;\n    &lt;title&gt;Título de la Página&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;!-- El contenido visible va aquí --&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n<ul>\n    <li><code>&lt;!DOCTYPE html&gt;</code>: Declaración que define que el documento es HTML5.</li>\n    <li><code>&lt;html&gt;</code>: El elemento raíz de la página.</li>\n    <li><code>&lt;head&gt;</code>: Contiene metadatos (información sobre el documento), como el título (<code>&lt;title&gt;</code>) que aparece en la pestaña del navegador, enlaces a CSS y el juego de caracteres.</li>\n    <li><code>&lt;body&gt;</code>: Contiene todo el contenido visible de la página web.</li>\n</ul>\n\n<h3>3. Etiquetas Esenciales para Contenido</h3>\n\n<h4>Títulos (Headings)</h4>\n<p>Se usan para titular secciones y subsecciones. Van del <code>&lt;h1&gt;</code> (el más importante) al <code>&lt;h6&gt;</code> (el menos importante).</p>\n\n<h4>Enlaces (Anchors)</h4>\n<p>La etiqueta <code>&lt;a&gt;</code> crea hipervínculos. El atributo <code>href</code> (hypertext reference) especifica la URL de destino.</p>\n\n<h4>Listas</h4>\n<p>Hay dos tipos principales: desordenadas (<code>&lt;ul&gt;</code>) y ordenadas (<code>&lt;ol&gt;</code>), con ítems (<code>&lt;li&gt;</code>).</p>\n\n<h4>Tablas</h4>\n<p>Se usan para mostrar datos tabulares con <code>&lt;table&gt;</code>, <code>&lt;tr&gt;</code>, <code>&lt;th&gt;</code>, y <code>&lt;td&gt;</code>.</p>',
        duration: 45,
      },
      {
        id: '1.3',
        title: 'HTML semántico y buenas prácticas',
        content: '<h2>La Magia del Contexto: HTML Semántico</h2>\n<p>El <strong>HTML Semántico</strong> consiste en elegir la etiqueta HTML correcta según el <strong>significado</strong> de su contenido, no por cómo se ve. Usar etiquetas como <code>&lt;header&gt;</code>, <code>&lt;nav&gt;</code>, <code>&lt;main&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;section&gt;</code>, <code>&lt;aside&gt;</code> y <code>&lt;footer&gt;</code> es crucial por tres razones:</p><ol><li><strong>Accesibilidad:</strong> Ayuda a los lectores de pantalla a entender la estructura de tu página.</li><li><strong>SEO:</strong> Ayuda a los motores de búsqueda a indexar mejor tu contenido.</li><li><strong>Mantenibilidad:</strong> Hace que tu código sea más legible y fácil de entender.</li></ol><p>Siempre usa la etiqueta más apropiada para el contenido y sigue una jerarquía de títulos lógica (h1, h2, h3...).</p>',
        duration: 30,
      },
      {
        id: '1.4',
        title: 'CSS básico: selectores, propiedades, colores',
        content: '<h2>Dando Vida a la Web: Introducción a CSS</h2><p>CSS (Cascading Style Sheets) es el lenguaje que usamos para dar estilo a los elementos HTML. La forma recomendada de usarlo es a través de una hoja de estilos externa enlazada en el <code>&lt;head&gt;</code> del HTML.</p><h3>Sintaxis de una Regla CSS</h3><p><code>selector { propiedad: valor; }</code></p><h3>Selectores Fundamentales</h3><ul><li><strong>Etiqueta:</strong> <code>p { ... }</code> (selecciona todos los párrafos)</li><li><strong>Clase:</strong> <code>.mi-clase { ... }</code> (selecciona todos los elementos con <code>class="mi-clase"</code>). Es el más usado.</li><li><strong>ID:</strong> <code>#mi-id { ... }</code> (selecciona el único elemento con <code>id="mi-id"</code>).</li></ul><h3>Propiedades Básicas</h3><p>Controlan el color del texto (<code>color</code>), el fondo (<code>background-color</code>), el tamaño de fuente (<code>font-size</code>), la familia de fuente (<code>font-family</code>) y la alineación del texto (<code>text-align</code>).</p>',
        duration: 45,
      },
      {
        id: '1.5',
        title: 'Box model y layout',
        content: '<h2>El Concepto Fundamental de Diseño Web: El Modelo de Caja (Box Model)</h2>\n<p>En CSS, todo elemento es una caja rectangular. El <strong>Modelo de Caja</strong> define su tamaño y está compuesto por cuatro partes, de adentro hacia afuera: <strong>Contenido</strong>, <strong>Padding</strong> (relleno interior), <strong>Border</strong> (borde) y <strong>Margin</strong> (margen exterior).</p><p>Para simplificar los cálculos de tamaño, es una práctica estándar y fundamental usar la siguiente regla en tu CSS:</p><pre><code class="language-css">* {\n  box-sizing: border-box;\n}</code></pre><p>Esta regla asegura que cuando defines un <code>width</code> y <code>height</code> para un elemento, estas dimensiones incluyan el padding y el borde, haciendo la maquetación mucho más intuitiva.</p>',
        duration: 50,
      },
       {
        id: '1.6',
        title: 'Flexbox y Grid',
        content: '<h2>Layouts Modernos: Flexbox y Grid</h2>\n<p>Flexbox y Grid son tecnologías de CSS para organizar elementos.</p><h3>Flexbox (1D)</h3><p>Diseñado para alinear elementos en una sola dimensión (fila o columna). Se activa con <code>display: flex;</code>. Propiedades clave del contenedor son <code>justify-content</code> (alineación en el eje principal) y <code>align-items</code> (alineación en el eje cruzado).</p><h3>CSS Grid (2D)</h3><p>Diseñado para maquetación en dos dimensiones (filas y columnas). Se activa con <code>display: grid;</code>. Propiedades clave son <code>grid-template-columns</code>, <code>grid-template-rows</code> y <code>gap</code>.</p><h3>¿Cuándo usar cuál?</h3><ul><li><strong>Flexbox:</strong> Para componentes y alineación (barras de navegación, tarjetas).</li><li><strong>Grid:</strong> Para el layout general de la página.</li></ul>',
        duration: 60,
      },
      {
        id: '1.7',
        title: 'Introducción a Git y GitHub',
        content: '<h2>La Red de Seguridad del Desarrollador: Git y GitHub</h2>\n<p>El <strong>Control de Versiones</strong> es un sistema que registra los cambios en archivos a lo largo del tiempo, permitiéndote recuperar versiones específicas. Es como una máquina del tiempo para tu código.</p><h3>Git vs. GitHub</h3><ul><li><strong>Git:</strong> Es el software de control de versiones distribuido que se ejecuta en tu máquina. Te permite hacer "commits" (instantáneas de tu código) de forma local.</li><li><strong>GitHub:</strong> Es una plataforma web que aloja repositorios de Git. Sirve como copia de seguridad en la nube, facilita la colaboración con otros desarrolladores y actúa como tu portafolio profesional.</li></ul>',
        duration: 45,
      },
      {
        id: '1.8',
        title: 'Git básico: commits, ramas, merge',
        content: '<h2>Manos a la Obra: Comandos Esenciales de Git</h2>\n<p>El flujo de trabajo básico que usarás constantemente.</p><ol><li><strong><code>git init</code>:</strong> Inicializa un repositorio en tu proyecto.</li><li><strong><code>git status</code>:</strong> Revisa el estado de tus archivos.</li><li><strong><code>git add .</code>:</strong> Prepara todos los cambios para ser guardados (staging).</li><li><strong><code>git commit -m "Mensaje descriptivo"</code>:</strong> Crea una instantánea permanente de tus cambios.</li><li><strong><code>git branch nombre-rama</code>:</strong> Crea una nueva línea de desarrollo.</li><li><strong><code>git checkout nombre-rama</code>:</strong> Te mueves a esa rama para trabajar.</li><li><strong><code>git merge nombre-rama</code>:</strong> Fusiona los cambios de una rama en tu rama actual.</li><li><strong><code>git push origin main</code>:</strong> Sube tus commits a GitHub.</li></ol>',
        duration: 60,
      },
    ],
    project: {
      title: 'Página de perfil personal',
      description:
        'Crea tu propia página de perfil usando HTML y CSS, y súbela a un repositorio de GitHub.',
    },
    quizId: 'quiz_1',
  },
  {
    id: '2',
    title: 'MÓDULO 2: Programación con JavaScript',
    objective: 'Dominar JavaScript para lógica de programación, manipulación del DOM y trabajo con datos',
    classes: [
      {
        id: '2.1',
        title: 'Variables, tipos de datos y operadores',
        content: '<h2>La Verdad sobre JavaScript: Tipos, Coerción y Comparaciones</h2><p>JavaScript es un lenguaje de "tipado dinámico". Es crucial entender sus tipos primitivos (String, Number, Boolean, null, undefined) y cómo funciona la <strong>coerción de tipo</strong> (conversión automática de tipos).</p><p>Para evitar errores, la regla de oro es usar siempre el operador de <strong>igualdad estricta (<code>===</code>)</strong> y el de desigualdad estricta (<code>!==</code>), que comparan valor y tipo sin realizar coerción.</p><pre><code class="language-javascript">console.log(5 == "5");  // true (débil, con coerción)\nconsole.log(5 === "5"); // false (estricta, sin coerción)</code></pre>',
        duration: 45,
      },
      {
        id: '2.2',
        title: 'Condicionales y bucles',
        content: '<h2>Tomando Decisiones y Repitiendo Tareas</h2><h3>Condicionales</h3><p>Permiten que tu código ejecute diferentes bloques según una condición. Los principales son <code>if</code>, <code>else if</code>, y <code>else</code>.</p><pre><code class="language-javascript">if (edad >= 18) {\n  console.log("Es mayor de edad");\n} else {\n  console.log("Es menor de edad");\n}</code></pre><h3>Bucles</h3><p>Permiten ejecutar un bloque de código múltiples veces. Los más comunes son:</p><ul><li><strong><code>for</code>:</strong> Cuando sabes de antemano cuántas veces quieres repetir.</li><li><strong><code>while</code>:</strong> Cuando la repetición depende de una condición que puede cambiar.</li><li><strong><code>for...of</code>:</strong> Para iterar sobre los elementos de un array.</li></ul>',
        duration: 45,
      },
      {
        id: '2.3',
        title: 'Funciones y scope',
        content: '<h2>Bloques de Código Reutilizables: Funciones</h2><p>Una <strong>función</strong> es un bloque de código diseñado para realizar una tarea particular. Se define una vez y se puede ejecutar (llamar) muchas veces.</p><h3>Scope (Ámbito)</h3><p>El <strong>scope</strong> determina la accesibilidad de las variables. En JavaScript moderno (con <code>let</code> y <code>const</code>), las variables tienen un ámbito de bloque (solo existen dentro de las llaves <code>{}</code> donde fueron declaradas). Esto ayuda a prevenir errores y a mantener el código organizado.</p>',
        duration: 50,
      },
      {
        id: '2.4',
        title: 'Arreglos y objetos',
        content: '<h2>Colecciones de Datos</h2><h3>Arreglos (Arrays)</h3><p>Son listas ordenadas de valores. Puedes acceder a sus elementos por su índice (empezando en 0).</p><pre><code class="language-javascript">const frutas = ["manzana", "plátano", "naranja"];\nconsole.log(frutas[1]); // "plátano"</code></pre><h3>Objetos (Objects)</h3><p>Son colecciones de pares clave-valor. Se usan para agrupar datos relacionados.</p><pre><code class="language-javascript">const usuario = {\n  nombre: "Alberto",\n  edad: 30,\n  esEstudiante: true\n};\nconsole.log(usuario.nombre); // "Alberto"</code></pre>',
        duration: 50,
      },
      {
        id: '2.5',
        title: 'Manipulación del DOM',
        content: '<h2>JavaScript y el Navegador: El DOM</h2><p>El <strong>DOM (Document Object Model)</strong> es una representación en forma de árbol de tu documento HTML. JavaScript puede interactuar con este árbol para leer y modificar el contenido, la estructura y el estilo de una página de forma dinámica.</p><h3>Métodos Clave</h3><ul><li><strong><code>document.getElementById("miId")</code>:</strong> Selecciona un elemento por su ID.</li><li><strong><code>document.querySelector(".miClase")</code>:</strong> Selecciona el primer elemento que coincida con un selector de CSS.</li><li><strong><code>elemento.textContent = "Nuevo texto"</code>:</strong> Cambia el texto de un elemento.</li><li><strong><code>elemento.style.color = "blue"</code>:</strong> Cambia el estilo CSS de un elemento.</li><li><strong><code>elemento.classList.add("nueva-clase")</code>:</strong> Añade una clase CSS.</li></ul>',
        duration: 60,
      },
      {
        id: '2.6',
        title: 'Eventos y formularios',
        content: '<h2>Haciendo Páginas Interactovas: Eventos</h2><p>Los <strong>eventos</strong> son acciones que ocurren en el navegador, como un clic de un usuario, el envío de un formulario o la finalización de la carga de una imagen. Podemos "escuchar" estos eventos y ejecutar código en respuesta.</p><pre><code class="language-javascript">const miBoton = document.getElementById("miBoton");\n\nmiBoton.addEventListener("click", function() {\n  alert("¡Botón presionado!");\n});</code></pre><p>Para los formularios, es común escuchar el evento <code>submit</code> y usar <code>event.preventDefault()</code> para evitar que la página se recargue, permitiéndonos manejar los datos con JavaScript.</p>',
        duration: 60,
      },
       {
        id: '2.7',
        title: 'JSON y almacenamiento local',
        content: '<h2>Persistencia de Datos en el Navegador</h2><h3>JSON (JavaScript Object Notation)</h3><p>Es un formato de texto ligero para el intercambio de datos. A pesar de su nombre, es independiente del lenguaje, pero su sintaxis es un subconjunto de la de los objetos de JavaScript.</p><ul><li><strong><code>JSON.stringify(objeto)</code>:</strong> Convierte un objeto de JavaScript a una cadena JSON.</li><li><strong><code>JSON.parse(cadenaJson)</code>:</strong> Convierte una cadena JSON a un objeto de JavaScript.</li></ul><h3>Almacenamiento Local (Local Storage)</h3><p>Permite guardar pares clave-valor en el navegador de forma persistente (no se borran al cerrar la pestaña). Solo puede almacenar cadenas de texto, por lo que es común usar JSON para guardar objetos.</p><pre><code class="language-javascript">const usuario = { nombre: "Alberto" };\nlocalStorage.setItem("datosUsuario", JSON.stringify(usuario));\nconst usuarioGuardado = JSON.parse(localStorage.getItem("datosUsuario"));</code></pre>',
        duration: 45,
      },
      {
        id: '2.8',
        title: 'Fetch API: consumir datos de APIs',
        content: '<h2>Obteniendo Datos del Mundo Exterior: Fetch API</h2><p>La <strong>Fetch API</strong> es la forma moderna en JavaScript de realizar peticiones de red (por ejemplo, a una API REST) para obtener o enviar datos. Se basa en <strong>Promesas</strong>.</p><p>El patrón más común utiliza <code>async/await</code> para escribir código asíncrono que parece síncrono, facilitando su lectura y manejo de errores.</p><pre><code class="language-javascript">async function obtenerUsuarios() {\n  try {\n    const respuesta = await fetch("https://jsonplaceholder.typicode.com/users");\n    if (!respuesta.ok) {\n      throw new Error("Error en la red");\n    }\n    const datos = await respuesta.json();\n    console.log(datos);\n  } catch (error) {\n    console.error("Hubo un problema:", error);\n  }\n}\n\nobtenerUsuarios();</code></pre>',
        duration: 60,
      },
    ],
    project: {
      title: 'Aplicación de tareas (ToDo List)',
      description:
        'Crea una ToDo List funcional que permita añadir, eliminar y marcar tareas como completadas, guardando los datos en el Local Storage.',
    },
    quizId: 'quiz_2',
  },
  {
    id: '3',
    title: 'MÓDULO 3: Desarrollo Front-End con Frameworks',
    objective: 'Aprender React y fundamentos de otros frameworks populares',
    classes: [
      {
        id: '3.1',
        title: '¿Qué es un framework y por qué usar React?',
        content: '<h2>El Ecosistema Moderno: Librerías vs. Frameworks</h2><p>Cuando construyes una aplicación web compleja, no quieres reinventar la rueda. Las <strong>librerías</strong> (como React) te dan herramientas específicas que tú controlas, mientras que los <strong>frameworks</strong> (como Next.js o Angular) te dan un plan de construcción completo que guía la estructura de tu app.</p><h3>¿Por qué React?</h3><ol><li><strong>Arquitectura Basada en Componentes:</strong> Divide la UI en piezas reutilizables.</li><li><strong>UI Declarativa:</strong> Le dices a React cómo quieres que se vea la UI para un estado determinado, y él se encarga del resto.</li><li><strong>Virtual DOM:</strong> Optimiza las actualizaciones del DOM para un rendimiento superior.</li></ol>',
        duration: 45,
      },
      {
        id: '3.2',
        title: 'Componentes, props y JSX',
        content: '<h2>Los Bloques de Construcción: Componentes, JSX y Props</h2>\n<p>El corazón de React es el <strong>componente</strong>, una función de JavaScript (con nombre en mayúscula) que devuelve <strong>JSX</strong>.</p><h3>JSX</h3><p>Es una extensión de sintaxis que permite escribir "HTML" en JavaScript. Se transforma en llamadas a funciones de React.</p><h3>Props</h3><p>Son la forma de pasar datos de un componente padre a uno hijo. Son inmutables y fluyen en una sola dirección.</p><pre><code class="language-jsx">// Padre\n<SaludoPersonalizado nombre="Alberto" />\n\n// Hijo\nfunction SaludoPersonalizado(props) {\n  return <h1>Hola, {props.nombre}</h1>;\n}</code></pre>',
        duration: 90,
      },
      {
        id: '3.3',
        title: 'State y ciclo de vida',
        content: '<h2>La Memoria de los Componentes: State</h2><p>Para que un componente pueda recordar información que cambia con el tiempo (como un contador o el texto de un input), usamos el <strong>estado (state)</strong>. En los componentes de función, esto se gestiona con el Hook <strong><code>useState</code></strong>.</p><pre><code class="language-jsx">import { useState } from "react";\n\nfunction Contador() {\n  const [contador, setContador] = useState(0); // 0 es el valor inicial\n\n  // Al llamar a setContador, React vuelve a renderizar el componente\n  return <button onClick={() => setContador(contador + 1)}>{contador}</button>\n}</code></pre><p>React solo vuelve a renderizar un componente cuando cambian sus props o su estado.</p>',
        duration: 90,
      },
      {
        id: '3.4',
        title: 'React Router',
        content: '<h2>Navegando en Aplicaciones de Página Única (SPA) con Next.js</h2>\n<p>En las aplicaciones web modernas, no queremos que la página se recargue completamente cada vez que el usuario navega a una nueva sección. Este concepto se llama <strong>Single Page Application (SPA)</strong>, y el proceso de cambiar las vistas sin recargar la página se conoce como <strong>enrutamiento del lado del cliente</strong>.</p>\n<h3>El Enrutamiento Basado en Archivos de Next.js</h3>\n<p>Mientras que en React puro se usa una librería como <code>react-router-dom</code>, <strong>Next.js integra su propio sistema de enrutamiento potente y optimizado</strong>, conocido como el <strong>App Router</strong>. Este sistema se basa en el sistema de archivos, lo que lo hace muy intuitivo:</p>\n<ul>\n    <li><strong>Las carpetas definen las rutas:</strong> Cada carpeta dentro del directorio <code>src/app/</code> se convierte en un segmento de la URL. Por ejemplo, <code>src/app/dashboard/settings/page.tsx</code> se accederá en <code>http://tuweb.com/dashboard/settings</code>.</li>\n    <li><strong>El archivo <code>page.tsx</code> es la UI:</strong> El componente de React exportado desde un archivo <code>page.tsx</code> es lo que se renderizará para esa ruta específica.</li>\n    <li><strong>El archivo <code>layout.tsx</code> define la UI compartida:</strong> Un layout es un componente que envuelve a varias páginas. Es perfecto para elementos comunes como la barra de navegación (<code>Sidebar</code>), el pie de página o cualquier estructura que se repita. El layout del directorio raíz (<code>src/app/layout.tsx</code>) aplica a toda la aplicación.</li>\n</ul>\n<h3>Navegación entre Páginas</h3>\n<p>Para navegar entre las rutas de tu aplicación sin una recarga completa, Next.js proporciona el componente <strong><code>&lt;Link&gt;</code></strong>. Debes usarlo siempre en lugar de la etiqueta <code>&lt;a&gt;</code> tradicional para la navegación interna.</p>\n<pre><code class="language-jsx">\nimport Link from "next/link";\n\nfunction Navegacion() {\n  return (\n    <nav>\n      <Link href="/">Inicio</Link>\n      <Link href="/dashboard">Ir al Dashboard</Link>\n    </nav>\n  );\n}\n</code></pre>\n<p>Next.js automáticamente pre-carga el código de la página enlazada cuando el componente <code>&lt;Link&gt;</code> aparece en la pantalla, haciendo que la navegación se sienta instantánea.</p>',
        duration: 60,
      },
      {
        id: '3.5',
        title: 'Hooks (useState, useEffect, custom hooks)',
        content: '<h2>Enganchándose al Poder de React: Hooks Esenciales</h2>\n<p>Los <strong>Hooks</strong> son funciones especiales que te permiten "engancharte" a las características de React desde tus componentes de función. Son la base del desarrollo moderno en React.</p>\n\n<h3>1. <code>useState</code>: La Memoria del Componente</h3>\n<p>Como ya vimos, <code>useState</code> es el hook que nos permite añadir estado (variables que persisten entre renderizados) a nuestros componentes. Es la piedra angular de la interactividad.</p>\n\n<h3>2. <code>useEffect</code>: Manejando Efectos Secundarios</h3>\n<p>Un componente React idealmente solo calcula y devuelve JSX. Cualquier otra acción que interactúe con el "mundo exterior" es un <strong>efecto secundario</strong>. Ejemplos comunes incluyen:</p>\n<ul>\n    <li>Realizar una petición a una API (<code>fetch</code>).</li>\n    <li>Manipular directamente el DOM (aunque debe evitarse en lo posible).</li>\n    <li>Establecer suscripciones (como a un temporizador con <code>setInterval</code>).</li>\n</ul>\n<p><code>useEffect</code> te permite ejecutar estos efectos después de que el componente se haya renderizado. Su sintaxis es: <code>useEffect(funcionDelEfecto, [dependencias])</code>.</p>\n<ul>\n    <li><strong>La función de efecto:</strong> Es el código que se ejecutará.</li>\n    <li><strong>El array de dependencias:</strong> Controla <em>cuándo</em> se vuelve a ejecutar el efecto. Si una de las variables en este array cambia entre renderizados, el efecto se ejecuta de nuevo. Si se deja vacío (<code>[]</code>), el efecto se ejecuta solo una vez, cuando el componente se "monta" (aparece por primera vez).</li>\n</ul>\n\n<h3>3. Hooks Personalizados (Custom Hooks): La Clave de la Reutilización</h3>\n<p>Cuando te encuentras repitiendo la misma lógica de estado y efectos (por ejemplo, lógica para hacer un fetch de datos, o para leer del Local Storage) en varios componentes, puedes extraer esa lógica a tu propia función. Si esa función utiliza otros hooks (como <code>useState</code> o <code>useEffect</code>), se convierte en un <strong>Hook Personalizado</strong>. Por convención, sus nombres siempre deben empezar con <code>use</code>.</p>\n<p>En nuestro proyecto, <code>useLocalStorage</code> es un ejemplo perfecto de un hook personalizado. Encapsula toda la lógica de leer y escribir en el almacenamiento local del navegador, permitiéndonos usarlo en cualquier componente con una sola línea de código.</p>\n<pre><code class="language-jsx">\n// En use-local-storage.ts (nuestro custom hook)\nexport function useLocalStorage(key, initialValue) {\n  const [storedValue, setStoredValue] = useState(...);\n  useEffect(...);\n  return [storedValue, setStoredValue];\n}\n\n// En cualquier componente\nfunction MiComponente() {\n  const [nombre, setNombre] = useLocalStorage("nombre", "Invitado");\n  // ...\n}\n</code></pre>',
        duration: 120,
      },
      {
        id: '3.6',
        title: 'Manejo de formularios y validaciones',
        content: '<h2>La Interfaz entre Usuario y Aplicación: Formularios en React</h2>\n<p>El patrón estándar y más robusto para manejar formularios en React se conoce como <strong>componentes controlados</strong>. Esto significa que el estado del componente React se convierte en la "única fuente de verdad" para los datos del formulario.</p>\n\n<h3>¿Cómo funciona?</h3>\n<ol>\n    <li>Se declara una variable de estado con <code>useState</code> para cada campo del formulario.</li>\n    <li>La prop <code>value</code> de cada input se enlaza directamente a su correspondiente variable de estado.</li>\n    <li>Se define una función manejadora (handler) para el evento <code>onChange</code> de cada input. Esta función se encarga de llamar a la función `set` del estado para actualizar el valor con cada pulsación de tecla (<code>e.target.value</code>).</li>\n</ol>\n\n<pre><code class="language-jsx">\nfunction FormularioSimple() {\n  const [nombre, setNombre] = useState("");\n\n  const handleSubmit = (e) => {\n    e.preventDefault(); // Previene la recarga de la página\n    alert(`Hola, ${nombre}`);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <label>Nombre:</label>\n      <input \n        type="text" \n        value={nombre} \n        onChange={(e) => setNombre(e.target.value)} \n      />\n      <button type="submit">Enviar</button>\n    </form>\n  );\n}\n</code></pre>\n\n<h3>Validación y Librerías</h3>\n<p>Manejar formularios más complejos con múltiples campos, validaciones y mensajes de error puede volverse tedioso. Para estos casos, la comunidad de React ha creado librerías excelentes que simplifican enormemente el proceso.</p>\n<p>En nuestro proyecto, utilizamos <strong>React Hook Form</strong> en conjunto con <strong>Zod</strong>:</p>\n<ul>\n    <li><strong>React Hook Form:</strong> Es una librería de alto rendimiento para la gestión de formularios. Optimiza los re-renderizados y simplifica el manejo del estado del formulario.</li>\n    <li><strong>Zod:</strong> Es una librería para la declaración y validación de esquemas de datos. Defines la "forma" que deben tener tus datos y Zod se encarga de validar que se cumpla, generando errores descriptivos.</li>\n</ul>\n<p>La combinación de ambas (a través del resolver <code>@hookform/resolvers/zod</code>) es una práctica profesional estándar para construir formularios robustos, seguros y fáciles de mantener.</p>',
        duration: 90,
      },
      {
        id: '3.7',
        title: 'Introducción a Vue.js',
        content: '<h2>Una Alternativa Progresiva: Introducción a Vue.js</h2><p>Vue.js es otro framework de JavaScript extremadamente popular, conocido por su curva de aprendizaje más suave y su excelente documentación. Características principales:</p><ul><li><strong>Sintaxis Basada en Plantillas:</strong> Utiliza plantillas que se asemejan al HTML clásico, lo que puede resultar muy familiar para desarrolladores que vienen de ese mundo.</li><li><strong>Reactividad:</strong> Su sistema de reactividad actualiza la UI automáticamente cuando los datos cambian, de forma muy eficiente.</li><li><strong>Componentes de un Solo Archivo (.vue):</strong> Encapsulan HTML, CSS y JavaScript en un único archivo, promoviendo una excelente organización.</li><li><strong>Progresivo:</strong> Puedes usar Vue para controlar solo una pequeña parte de una página existente o para construir una SPA completa desde cero.</li></ul>',
        duration: 60,
      },
      {
        id: '3.8',
        title: 'Introducción a Angular',
        content: '<h2>El Framework Todo Incluido: Introducción a Angular</h2><p>Angular (desarrollado y mantenido por Google) no es solo una librería, sino una "plataforma" completa y opinada para construir aplicaciones a gran escala y nivel empresarial. Características principales:</p><ul><li><strong>Basado en TypeScript:</strong> Impone el uso de TypeScript desde el principio, aportando robustez, autocompletado y detección temprana de errores.</li><li><strong>Arquitectura Opinada:</strong> Tiene una estructura muy definida (Módulos, Componentes, Servicios, Inyección de Dependencias), lo que es ideal para estandarizar el código en equipos grandes.</li><li><strong>Inyección de Dependencias:</strong> Un patrón de diseño central en el framework que facilita la gestión del código, su reutilización y, sobre todo, el testing.</li><li><strong>Ecosistema Completo:</strong> Angular viene con soluciones integradas para enrutamiento, cliente HTTP, gestión de formularios y más.</li></ul>',
        duration: 60,
      },
    ],
    project: {
      title: 'App de notas con React',
      description:
        'Desarrolla una aplicación de notas completa utilizando React, manejando estado, componentes y routing.',
    },
    quizId: 'quiz_3',
  },
  {
    id: '4',
    title: 'MÓDULO 4: Desarrollo Back-End con Next.js',
    objective: 'Crear APIs, manejar datos y lógica de servidor directamente en Next.js',
    classes: [
      { 
        id: '4.1', 
        title: 'Introducción al desarrollo back-end', 
        content: '<h2>El Paradigma Full-Stack de Next.js</h2>\n<p>Tradicionalmente, el "back-end" era un servidor completamente separado, construido con tecnologías como Node.js/Express, Python/Django o Java/Spring. Su responsabilidad era manejar la lógica de negocio, la autenticación y la comunicación con la base de datos, exponiendo los datos a través de una API REST o GraphQL.</p>\n<p>Next.js, con la introducción del <strong>App Router</strong>, revoluciona este concepto. Permite escribir código de back-end directamente dentro de tu proyecto de React, difuminando las fronteras entre el front-end y el back-end.</p>\n<h3>Componentes de Servidor (Server Components)</h3>\n<p>Por defecto, todos los componentes en el App Router de Next.js son <strong>Componentes de Servidor</strong>. Esto significa que:</p>\n<ul>\n    <li>Se renderizan en el servidor, no en el navegador del cliente.</li>\n    <li>Pueden acceder directamente a recursos de back-end (como bases de datos o APIs internas) de forma segura, sin necesidad de una petición <code>fetch</code> explícita. ¡Tus claves de API y credenciales nunca se envían al cliente!</li>\n    <li>No se incluye su código JavaScript en el paquete que se envía al navegador, lo que resulta en páginas mucho más ligeras y rápidas.</li>\n    <li>No pueden usar estado (<code>useState</code>) ni efectos (<code>useEffect</code>), ya que no existen en el entorno del cliente.</li>\n</ul>\n<h3>Componentes de Cliente (Client Components)</h3>\n<p>Para añadir interactividad (manejar clics, estado, etc.), necesitas un <strong>Componente de Cliente</strong>. Para convertir un componente, simplemente añades la directiva <code>"use client";</code> al principio del archivo.</p>\n<p>Este modelo te permite construir aplicaciones increíblemente rápidas por defecto, y "optar por la interactividad" solo donde sea necesario.</p>', 
        duration: 60 
      },
      { 
        id: '4.2', 
        title: 'Route Handlers: Creando Endpoints de API', 
        content: '<h2>Construyendo tu Propia API con Next.js: Route Handlers</h2>\n<p>Si bien los Server Components son excelentes para obtener datos para renderizar una UI, a menudo necesitas crear endpoints de API específicos. Por ejemplo, para que tu aplicación móvil consuma datos, para exponer una API pública, o para manejar webhooks de servicios de terceros. Aquí es donde entran los <strong>Route Handlers</strong>.</p>\n<p>Los Route Handlers son la forma que tiene Next.js de permitirte crear APIs RESTful personalizadas, reemplazando la necesidad de un servidor Express separado para muchos casos de uso.</p>\n<h3>¿Cómo Funcionan?</h3>\n<p>La convención es simple: creas un archivo llamado <code>route.ts</code> (o <code>.js</code>) dentro de cualquier carpeta en tu directorio <code>app</code>. La ruta del archivo se mapea directamente a una URL. Dentro de este archivo, exportas funciones asíncronas nombradas según los verbos HTTP que quieres manejar: <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, etc.</p>\n<pre><code class="language-typescript">\n// En el archivo: src/app/api/hello/route.ts\n// Este código crea un endpoint en: http://tuweb.com/api/hello\n\nimport { NextResponse } from \'next/server\';\n\nexport async function GET(request: Request) {\n  // Puedes acceder a la petición, headers, etc.\n  return NextResponse.json({ message: "Hola, Mundo!" });\n}\n\nexport async function POST(request: Request) {\n  const body = await request.json(); // Leer el cuerpo de la petición\n  console.log(body);\n  return NextResponse.json({ received: true, data: body });\n}\n</code></pre>\n<h3><code>NextRequest</code> y <code>NextResponse</code></h3>\n<p>Next.js extiende las APIs nativas de <code>Request</code> y <code>Response</code> con objetos propios, <code>NextRequest</code> y <code>NextResponse</code>, que te dan más control. <code>NextResponse.json()</code>, por ejemplo, es una forma conveniente de devolver respuestas JSON con el `Content-Type` correcto automáticamente.</p><p>Los Route Handlers son la pieza clave para construir un back-end completo y robusto sin salir del ecosistema de Next.js, permitiéndote manejar cualquier tipo de lógica de servidor que necesites.</p>', 
        duration: 90 
      },
      { 
        id: '4.3', 
        title: 'Server Actions: Mutaciones de Datos Seguras', 
        content: '<h2>La Forma Moderna de Escribir Datos: Server Actions</h2>\n<p>Tradicionalmente, para enviar datos desde un formulario al servidor (por ejemplo, para crear un nuevo usuario o guardar una nota), se creaba un endpoint de API (con un Route Handler) que aceptara una petición <code>POST</code>, y luego se realizaba una llamada <code>fetch</code> desde el cliente a ese endpoint.</p>\n<p>Next.js simplifica radicalmente este proceso con las <strong>Server Actions</strong>. Son funciones de servidor que puedes llamar directamente desde tus componentes de cliente, especialmente desde formularios, sin tener que escribir endpoints de API manualmente.</p>\n<h3>¿Cómo Funcionan?</h3>\n<ol>\n    <li><strong>Definir la Acción:</strong> Creas una función asíncrona en un archivo de servidor (o directamente en un Server Component) y le añades la directiva <code>"use server";</code> al principio del archivo o de la función. Esta función puede recibir datos, como los de un formulario.</li>\n    <li><strong>Invocar desde el Cliente:</strong> En tu componente de cliente, en lugar de manejar el evento <code>onSubmit</code> del formulario con una función propia, pasas la Server Action directamente a la prop <code>action</code> del formulario.</li>\n</ol>\n<pre><code class="language-typescript">\n// En un archivo como `src/actions/user-actions.ts`\n"use server";\n\nexport async function createUser(formData: FormData) {\n  const name = formData.get("name") as string;\n  // Aquí iría la lógica para guardar el usuario en la base de datos\n  console.log("Creando usuario:", name);\n}\n</code></pre>\n<pre><code class="language-jsx">\n// En un Componente de Cliente (ej: `src/app/page.tsx` con "use client")\nimport { createUser } from "@/actions/user-actions";\n\nexport default function UserForm() {\n  return (\n    <form action={createUser}>\n      <input type="text" name="name" />\n      <button type="submit">Crear Usuario</button>\n    </form>\n  );\n}\n</code></pre>\n<p>Next.js se encarga automáticamente de crear y llamar a un endpoint RPC (Remote Procedure Call) privado, protegiéndolo de ataques comunes. Las Server Actions son el método recomendado para manejar mutaciones de datos en aplicaciones Next.js modernas, ya que reducen el código repetitivo y mejoran la experiencia de desarrollo.</p>', 
        duration: 90 
      },
      { 
        id: '4.4', 
        title: 'Conectando a Bases de Datos', 
        content: '<h2>La Persistencia de los Datos: Conexión a Bases de Datos con ORMs</h2>\n<p>Una aplicación real necesita guardar sus datos de forma permanente. Para ello, nos conectamos a una <strong>base de datos</strong>. Escribir consultas a la base de datos directamente en el lenguaje que esta entiende (como SQL) puede ser propenso a errores, difícil de mantener y vulnerable a ataques (inyección de SQL).</p>\n<h3>El Rol del ORM (Object-Relational Mapper)</h3>\n<p>Para solucionar esto, utilizamos una herramienta llamada <strong>ORM</strong>. Un ORM es una capa de abstracción que "mapea" las tablas de nuestra base de datos a objetos y clases en nuestro lenguaje de programación (TypeScript). Esto nos permite interactuar con la base de datos usando métodos y objetos familiares, en lugar de escribir consultas manualmente.</p>\n<p><strong>Prisma</strong> es el ORM de nueva generación líder en el ecosistema de TypeScript. Sus ventajas son:</p>\n<ul>\n    <li><strong>Seguridad de Tipos (Type-Safety):</strong> Si intentas acceder a un campo que no existe o pasar un tipo de dato incorrecto, TypeScript te avisará antes de que el código llegue a producción.</li>\n    <li><strong>Autocompletado:</strong> El editor de código te sugerirá los modelos y operaciones disponibles, agilizando el desarrollo.</li>\n    <li><strong>Gestión de Migraciones:</strong> Prisma facilita la evolución del esquema de tu base de datos a lo largo del tiempo de forma controlada.</li>\n</ul>\n\n<h3>Flujo de Trabajo Básico (Teórico)</h3>\n<ol>\n    <li><strong>Definir el Esquema:</strong> En un archivo <code>schema.prisma</code>, defines tus modelos de datos de forma declarativa.</li>\n    <li><strong>Migrar la Base de Datos:</strong> Con un comando, Prisma compara tu esquema con la base de datos y genera automáticamente las migraciones necesarias para sincronizarlas.</li>\n    <li><strong>Usar el Cliente de Prisma:</strong> Prisma genera un cliente de base de datos totalmente tipado que puedes importar y usar en tu código de servidor para realizar operaciones CRUD (Crear, Leer, Actualizar, Borrar).</li>\n</ol>\n\n<p><strong>Importante:</strong> Toda la comunicación con la base de datos a través del ORM debe ocurrir exclusivamente en el <strong>entorno del servidor</strong> (Server Components, Route Handlers, Server Actions). Las credenciales de la base de datos nunca deben ser expuestas al navegador del cliente.</p>', 
        duration: 120 
      },
      { 
        id: '4.5', 
        title: 'Autenticación en Next.js con Servicios Gestionados', 
        content: '<h2>Protegiendo tu Aplicación: Autenticación en Next.js</h2>\n<p>Toda aplicación seria necesita un sistema para identificar y verificar a sus usuarios. Construir un sistema de autenticación desde cero es complejo y arriesgado. Implica manejar contraseñas de forma segura (hashing y salting), gestionar tokens de sesión, protegerse contra ataques de fuerza bruta, implementar la recuperación de contraseñas, etc.</p>\n<h3>La Ventaja de los Servicios Gestionados (BaaS)</h3>\n<p>Afortunadamente, existen servicios de "Backend as a Service" (BaaS) como <strong>Firebase Authentication</strong>, Auth0 o Supabase Auth que resuelven este problema por nosotros. Utilizar un servicio gestionado es la práctica recomendada en el desarrollo moderno por varias razones:</p>\n<ul>\n    <li><strong>Seguridad:</strong> Delega la responsabilidad de la seguridad a expertos. Estos servicios son auditados constantemente y están protegidos contra las vulnerabilidades más comunes.</li>\n    <li><strong>Ahorro de Tiempo:</strong> Te permite centrarte en la lógica de tu aplicación en lugar de reinventar la rueda de la autenticación.</li>\n    <li><strong>Funcionalidades Adicionales:</strong> Ofrecen de serie inicio de sesión con proveedores sociales (Google, GitHub, etc.), autenticación multi-factor, y mucho más.</li>\n</ul>\n<h3>Flujo de Autenticación con Firebase en Nuestra App</h3>\n<p>Nuestra aplicación ya está integrada con Firebase Authentication. El flujo es el siguiente:</p>\n<ol>\n    <li><strong>Interacción en el Cliente:</strong> En la página de login (<code>/login</code>), el usuario introduce su email y contraseña.</li>\n    <li><strong>SDK de Firebase:</strong> Utilizamos el SDK de cliente de Firebase (<code>firebase/auth</code>) para enviar estas credenciales de forma segura a los servidores de Firebase a través de funciones como <code>signInWithEmailAndPassword</code>.</li>\n    <li><strong>Verificación de Firebase:</strong> Firebase verifica las credenciales en su base de datos segura.</li>\n    <li><strong>Gestión de Sesión:</strong> Si las credenciales son correctas, Firebase devuelve un token al cliente. El SDK de Firebase se encarga de almacenar este token de forma segura en el navegador y de gestionar la sesión del usuario.</li>\n    <li><strong>Estado de Autenticación:</strong> Nuestro <code>AuthContext</code> utiliza el hook <code>onAuthStateChanged</code>, que actúa como un "oyente". Este observador notifica a nuestra aplicación en tiempo real si el usuario ha iniciado sesión, ha cerrado sesión o su estado ha cambiado, permitiéndonos redirigir al usuario o actualizar la UI en consecuencia.</li>\n</ol>\n<p>Este enfoque nos da un sistema de autenticación robusto y de nivel de producción con un esfuerzo de implementación mínimo por nuestra parte.</p>', 
        duration: 120 
      },
      { 
        id: '4.6', 
        title: 'Middleware: Modificando Peticiones', 
        content: '<h2>El Guardián de tus Rutas: Middleware en Next.js</h2>\n<p>El <strong>Middleware</strong> en Next.js es una función que se ejecuta <em>antes</em> de que una petición llegue a su destino final (una página o un endpoint de API). Esto lo convierte en un punto de control centralizado y extremadamente potente para implementar lógica transversal que afecta a múltiples rutas.</p>\n<h3>¿Por Qué es Tan Importante?</h3>\n<p>Imagina que tienes 10 páginas en tu aplicación que solo deberían ser accesibles para usuarios autenticados. Sin middleware, tendrías que añadir la misma lógica de comprobación de sesión en cada una de esas 10 páginas. Con el middleware, lo defines una sola vez.</p>\n<h3>Casos de Uso Principales:</h3>\n<ul>\n    <li><strong>Autenticación y Autorización:</strong> Es el caso de uso más común. El middleware puede comprobar si existe un token de sesión válido en las cookies de la petición. Si no existe o no es válido, puede redirigir al usuario a la página de login. Esto protege tus rutas de forma eficiente.</li>\n    <li><strong>Redirecciones:</strong> Para marketing, seguimiento o cambios de estructura en tu web.</li>\n    <li><strong>Reescritura de URLs:</strong> Para presentar URLs más limpias a los usuarios (ej. <code>/perfil</code>) que internamente apuntan a otra ruta (ej. <code>/usuario/123</code>).</li>\n    <li><strong>A/B Testing:</strong> Mostrar diferentes versiones de una página a diferentes segmentos de usuarios.</li>\n    <li><strong>Internacionalización (i18n):</strong> Detectar la preferencia de idioma del usuario y redirigirlo a la versión correcta de la página (ej. <code>/en</code> o <code>/es</code>).</li>\n</ul>\n<h3>Implementación</h3>\n<p>Se crea un único archivo llamado <code>middleware.ts</code> (o <code>.js</code>) en la raíz de tu proyecto (al mismo nivel que `src`). Dentro, exportas una función `middleware` y, opcionalmente, un objeto `config` con un `matcher` para especificar a qué rutas se debe aplicar.</p>\n<pre><code class="language-typescript">\nimport { NextResponse } from \'next/server\'\nimport type { NextRequest } from \'next/server\'\n \nexport function middleware(request: NextRequest) {\n  // Lógica aquí... por ejemplo, comprobar si hay una cookie de sesión.\n  // Si no está autenticado, podemos redirigir:\n  // return NextResponse.redirect(new URL(\'/login\', request.url))\n}\n \n// El matcher define a qué rutas se aplicará el middleware\nexport const config = {\n  matcher: \'/dashboard/:path*\', // Protegerá todas las rutas bajo /dashboard\n}\n</code></pre>\n<p>El middleware es una pieza fundamental para la arquitectura de una aplicación Next.js segura y bien estructurada, permitiendo mantener la lógica de las páginas limpia y centrada en su contenido.</p>', 
        duration: 60 
      },
    ],
    project: {
      title: 'API de Tareas con Route Handlers y Server Actions',
      description: 'Crear los endpoints de API y las acciones de servidor para gestionar las tareas del proyecto ToDo List del módulo 2, pero esta vez del lado del servidor.',
    },
    quizId: 'quiz_4'
  },
  {
    id: '5',
    title: 'MÓDULO 5: DevOps, Testing y Deployment',
    objective: 'Preparar entornos profesionales, CI/CD, Docker y pruebas unitarias',
    classes: [
      { id: '5.1', title: 'Introducción a DevOps', content: '<h2>Cerrando el Círculo: De tu Código a Millones de Usuarios</h2>\n<p>Hasta ahora, hemos escrito código que funciona en nuestra máquina. Pero, ¿cómo llevamos esa aplicación al mundo real para que millones de personas puedan usarla de forma fiable y segura? Aquí es donde entra <strong>DevOps</strong>.</p>\n<p>DevOps no es una herramienta, sino una <strong>cultura y un conjunto de prácticas</strong> que unen el desarrollo de software (<strong>Dev</strong>) y las operaciones de TI (<strong>Ops</strong>). El objetivo es automatizar y mejorar el proceso de construcción, prueba y lanzamiento de software, haciéndolo más rápido y más fiable.</p>\n<h3>Los Pilares de DevOps</h3>\n<ol>\n    <li><strong>Planificación:</strong> Definir qué se va a construir.</li>\n    <li><strong>Codificación:</strong> El trabajo de desarrollo que ya hemos hecho.</li>\n    <li><strong>Construcción (Build):</strong> Compilar el código y empaquetarlo en un formato ejecutable.</li>\n    <li><strong>Pruebas (Testing):</strong> Automatizar las pruebas para asegurar que el nuevo código no rompe nada.</li>\n    <li><strong>Lanzamiento (Release):</strong> El acto de preparar una nueva versión para su despliegue.</li>\n    <li><strong>Despliegue (Deploy):</strong> Poner el software en producción.</li>\n    <li><strong>Operación y Monitorización:</strong> Mantener la aplicación funcionando y observar su rendimiento y errores.</li>\n</ol>\n<h3>¿Por Qué es Esencial para un Desarrollador Full Stack?</h3>\n<p>Un verdadero desarrollador Full Stack no solo escribe código. Entiende el ciclo de vida completo de la aplicación. Saber de DevOps te permite:</p>\n<ul>\n    <li><strong>Ser Autónomo:</strong> Puedes desplegar y mantener tus propias aplicaciones.</li>\n    <li><strong>Colaborar Eficazmente:</strong> Entiendes los desafíos de los equipos de operaciones y puedes escribir código que sea más fácil de desplegar y mantener.</li>\n    <li><strong>Mejorar la Calidad:</strong> La automatización de pruebas y despliegues reduce los errores humanos y aumenta la confianza en el producto.</li>\n</ul>\n<p>En este módulo, nos centraremos en las herramientas prácticas que hacen posible la cultura DevOps: Docker para la contenerización, GitHub Actions para la Integración y Despliegue Continuos (CI/CD) y Jest para el testing automatizado.</p>', duration: 60 },
      { id: '5.2', title: 'Docker básico', content: '<h2>Empaquetando tu Aplicación: Introducción a Docker</h2>\n<p>Una vez que tu aplicación funciona en tu máquina, ¿cómo te aseguras de que funcionará exactamente igual en la máquina de otro desarrollador, en un servidor de pruebas o en producción? La respuesta es la <strong>contenedorización</strong>, y la herramienta estándar para ello es <strong>Docker</strong>.</p>\n<h3>¿Qué es un Contenedor?</h3>\n<p>Un contenedor es una unidad estándar de software que empaqueta el código y todas sus dependencias para que la aplicación se ejecute de forma rápida y fiable en cualquier entorno informático. Resuelve el clásico problema de "en mi máquina funciona".</p>\n<h3>Imagen vs. Contenedor</h3>\n<p>Es crucial entender esta analogía:</p>\n<ul>\n    <li>Una <strong>Imagen Docker</strong> es una plantilla inmutable y de solo lectura con instrucciones para crear un contenedor. Es como el plano de una casa.</li>\n    <li>Un <strong>Contenedor Docker</strong> es una instancia en ejecución de una imagen. Es la casa construida a partir de ese plano. Puedes tener múltiples contenedores (casas) funcionando a partir de la misma imagen (plano).</li>\n</ul>\n<h3>El Dockerfile: La Receta de tu Imagen</h3>\n<p>Un <code>Dockerfile</code> es un archivo de texto que contiene todos los comandos, en orden, necesarios para construir una imagen Docker determinada. Le dice a Docker cómo ensamblar tu aplicación, paso a paso:</p>\n<ol>\n    <li>Empezar desde una imagen base (ej. una imagen oficial de Node.js).</li>\n    <li>Establecer el directorio de trabajo.</li>\n    <li>Copiar los archivos de tu aplicación.</li>\n    <li>Instalar las dependencias (ej. <code>npm install</code>).</li>\n    <li>Exponer un puerto (ej. el puerto 3000 para Next.js).</li>\n    <li>Definir el comando que se ejecutará cuando se inicie el contenedor (ej. <code>npm start</code>).</li>\n</ol>\n<h3>El Flujo de Trabajo Básico</h3>\n<p>El ciclo de vida es simple:</p>\n<ol>\n    <li>Escribes tu <code>Dockerfile</code>.</li>\n    <li>Ejecutas <code>docker build -t mi-app .</code> para crear la imagen a partir del Dockerfile y le pones una etiqueta (tag).</li>\n    <li>Ejecutas <code>docker run -p 3000:3000 mi-app</code> para iniciar un contenedor a partir de tu imagen, mapeando el puerto de tu máquina al puerto del contenedor.</li>\n</ol>', duration: 90 },
      { id: '5.3', title: 'Docker Compose y entornos escalables', content: '<h2>Orquestando Múltiples Servicios: Docker Compose</h2>\n<p>Las aplicaciones reales a menudo se componen de varios servicios que necesitan trabajar juntos: tu aplicación web, una base de datos, un servicio de caché, etc. Gestionar estos contenedores individualmente con <code>docker run</code> es tedioso e insostenible.</p>\n<p><strong>Docker Compose</strong> es una herramienta para definir y ejecutar aplicaciones Docker de múltiples contenedores. Con un único archivo de configuración <code>YAML</code>, puedes orquestar todo tu entorno con un solo comando.</p>\n<h3>El Archivo `docker-compose.yml`</h3>\n<p>Este archivo es el corazón de Docker Compose. En él, defines los <strong>servicios</strong> que componen tu aplicación. Cada servicio corresponde a un contenedor.</p>\n<pre><code class="language-yaml">\n# docker-compose.yml\nversion: \'3.8\'\n\nservices:\n  webapp:\n    build: . # Construye la imagen desde el Dockerfile en el directorio actual\n    ports:\n      - "3000:3000"\n    volumes:\n      - .:/app # Monta el código local en el contenedor para desarrollo en vivo\n    networks:\n      - app-network\n\n  database:\n    image: "postgres:13" # Usa una imagen oficial de PostgreSQL\n    environment:\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n    volumes:\n      - db-data:/var/lib/postgresql/data # Persiste los datos de la base de datos\n    networks:\n      - app-network\n\nvolumes:\n  db-data:\n\nnetworks:\n  app-network:\n</code></pre>\n<h3>Conceptos Clave</h3>\n<ul>\n    <li><strong>Servicios (`services`):</strong> Cada pieza de tu stack (tu app, la BD). Compose inicia un contenedor por cada servicio.</li>\n    <li><strong>Redes (`networks`):</strong> Compose crea una red privada por defecto. Los servicios dentro de esta red pueden comunicarse entre sí usando el nombre del servicio como si fuera un nombre de host (ej., desde `webapp` puedes hacer una petición a `http://database:5432`).</li>\n    <li><strong>Volúmenes (`volumes`):</strong> Son el mecanismo para persistir datos fuera del ciclo de vida del contenedor. Esencial para las bases de datos.</li>\n</ul>\n<h3>Comandos Esenciales</h3>\n<ul>\n    <li><strong><code>docker-compose up</code>:</strong> Construye, (re)crea, inicia y adjunta los contenedores para un conjunto de servicios. Con el flag <code>-d</code> se ejecuta en segundo plano.</li>\n    <li><strong><code>docker-compose down</code>:</strong> Detiene y elimina los contenedores, redes, y volúmenes definidos en el archivo.</li>\n</ul>', duration: 90 },
      { id: '5.4', title: 'GitHub Actions y CI/CD', content: '<h2>La Automatización Definitiva: CI/CD con GitHub Actions</h2>\n<p>Hemos visto cómo empaquetar nuestra aplicación. Ahora, vamos a automatizar el proceso para que cada vez que subamos código nuevo, este se pruebe y se prepare para el despliegue sin intervención manual. Esto es <strong>CI/CD (Integración Continua y Despliegue Continuo)</strong>.</p>\n<h3>¿Qué es CI/CD?</h3>\n<ul>\n    <li><strong>Integración Continua (CI):</strong> Es la práctica de fusionar todos los cambios de código de los desarrolladores en una rama principal de forma automática y frecuente. Cada fusión desencadena una <strong>construcción (build)</strong> y una serie de <strong>pruebas automatizadas</strong>. El objetivo es detectar problemas de integración lo antes posible.</li>\n    <li><strong>Despliegue Continuo (CD):</strong> Es el siguiente paso. Cada cambio que pasa todas las pruebas de CI se despliega automáticamente en producción.</li>\n</ul>\n<h3>GitHub Actions: CI/CD Integrado en tu Repositorio</h3>\n<p><strong>GitHub Actions</strong> es la herramienta que nos permite definir estos flujos de trabajo de automatización directamente en nuestro repositorio de GitHub. Se configuran mediante archivos <code>YAML</code> en una carpeta especial llamada <code>.github/workflows</code>.</p>\n<h3>Conceptos Clave de un Workflow</h3>\n<ul>\n    <li><strong>Workflow:</strong> El proceso automatizado completo.</li>\n    <li><strong>Events (Eventos):</strong> El disparador que inicia el workflow (ej. un <code>push</code> a la rama <code>main</code>, o la creación de un <code>pull request</code>).</li>\n    <li><strong>Jobs (Trabajos):</strong> Un conjunto de pasos que se ejecutan en un mismo entorno virtual (llamado "runner").</li>\n    <li><strong>Steps (Pasos):</strong> Una tarea individual que puede ejecutar un comando o una "acción".</li>\n    <li><strong>Actions (Acciones):</strong> Piezas de código reutilizables que realizan tareas complejas (ej. <code>actions/checkout</code> para descargar tu código, o <code>actions/setup-node</code> para configurar Node.js).</li>\n</ul>\n<h3>Ejemplo de Workflow Básico para CI</h3>\n<p>Este es un ejemplo de un archivo <code>.github/workflows/ci.yml</code> para una aplicación Next.js:</p>\n<pre><code class="language-yaml">\nname: Node.js CI\n\non:\n  push:\n    branches: [ "main" ]\n  pull_request:\n    branches: [ "main" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js 20.x\n      uses: actions/setup-node@v3\n      with:\n        node-version: "20.x"\n        cache: \'npm\'\n    - run: npm ci\n    - run: npm run build\n    - run: npm test\n</code></pre>\n<p>Este workflow se ejecuta en cada push o pull request a `main`, descarga el código, instala las dependencias de forma limpia, construye la aplicación y ejecuta las pruebas. Si algún paso falla, el workflow se detiene y notifica el error, impidiendo que el código defectuoso llegue a producción.</p>', duration: 120 },
      { id: '5.5', title: 'Testing con Jest y Supertest', content: '<h2>La Red de Seguridad del Código: Testing Automatizado</h2>\n<p>Escribir código sin pruebas es como construir un edificio sin inspeccionar los cimientos. El <strong>testing automatizado</strong> es un conjunto de prácticas y herramientas que nos permiten verificar que nuestro código hace lo que se supone que debe hacer, de forma automática y repetible. Es una pieza angular de la Integración Continua (CI) y del desarrollo de software de calidad.</p>\n<h3>¿Por Qué Escribir Pruebas?</h3>\n<ul>\n    <li><strong>Confianza:</strong> Permiten realizar cambios y refactorizaciones con la seguridad de que no hemos roto nada (prevención de regresiones).</li>\n    <li><strong>Calidad:</strong> Obligan a pensar en los casos límite y mejoran el diseño del código.</li>\n    <li><strong>Documentación Viva:</strong> Las pruebas describen cómo debe comportarse una pieza de código.</li>\n</ul>\n<h3>Herramientas Clave en el Ecosistema Next.js/React</h3>\n<p>Next.js viene con una integración de primera clase para <strong>Jest</strong>, el framework de testing más popular en el mundo de JavaScript.</p>\n<ul>\n    <li><strong>Jest:</strong> Es el "corredor de pruebas" (test runner). Proporciona el entorno para ejecutar las pruebas, una librería de aserciones para verificar los resultados (ej. <code>expect(resultado).toBe(true)</code>), y potentes capacidades de "mocking" (simulación de dependencias).</li>\n    <li><strong>React Testing Library:</strong> Es la librería recomendada para probar componentes de React. Su filosofía es probar los componentes de la misma manera que un usuario los utilizaría. En lugar de comprobar detalles de implementación (como el estado interno de un componente), se interactúa con la UI (buscando texto, haciendo clic en botones) y se comprueba el resultado visible.</li>\n</ul>\n<h3>Ejemplo: Probando un Componente Simple</h3>\n<p>Imaginemos un componente contador simple. La prueba correspondiente se vería así:</p>\n<pre><code class="language-jsx">\n// Importaciones necesarias\nimport { render, screen, fireEvent } from \'@testing-library/react\';\nimport Counter from \'./Counter\'; // Nuestro componente\n\ndescribe(\'Counter\', () => {\n  it(\'should render with initial value of 0 and increment on click\', () => {\n    // 1. Renderizar el componente\n    render(<Counter />);\n\n    // 2. Buscar elementos en la UI como lo haría un usuario\n    const countElement = screen.getByText(/0/);\n    const buttonElement = screen.getByRole(\'button\', { name: /increment/i });\n\n    // 3. Aserción inicial: verificar que el contador empieza en 0\n    expect(countElement).toBeInTheDocument();\n\n    // 4. Simular la interacción del usuario\n    fireEvent.click(buttonElement);\n\n    // 5. Aserción final: verificar que el contador se ha actualizado\n    expect(screen.getByText(/1/)).toBeInTheDocument();\n  });\n});\n</code></pre>\n<p>Esta prueba asegura que el componente `Counter` se renderiza correctamente y que la interacción del usuario produce el resultado esperado, proporcionando una gran confianza en su funcionamiento sin acoplarse a cómo está implementado por dentro.</p>', duration: 120 },
      { id: '5.6', title: 'Entornos de staging y producción', content: '<h2>El Ciclo de Vida del Software Profesional: Entornos</h2>\n<p>El código que escribimos no va directamente desde nuestra máquina a los usuarios. Pasa por una serie de entornos controlados para garantizar la calidad y la estabilidad. Los tres entornos principales son:</p>\n<ol>\n    <li><strong>Desarrollo (Development):</strong> Tu máquina local. Es un entorno caótico y en constante cambio.</li>\n    <li><strong>Staging (o Pre-producción):</strong> Un entorno que es un clon exacto del de producción. Sirve como el último campo de pruebas antes de un lanzamiento. Aquí se realizan las pruebas de aceptación del usuario (UAT), las demos a los stakeholders y las pruebas de carga finales. El objetivo es encontrar errores en un contexto realista antes de que afecten a los usuarios reales.</li>\n    <li><strong>Producción (Production):</strong> El entorno real donde los usuarios interactúan con la aplicación. La estabilidad, el rendimiento y la seguridad son las máximas prioridades. Cualquier cambio aquí se hace con extremo cuidado.</li>\n</ol>\n<h3>Gestión de la Configuración</h3>\n<p>Cada entorno necesita una configuración diferente (por ejemplo, una base de datos de prueba para staging y una base de datos real para producción). Esta configuración se gestiona a través de <strong>variables de entorno</strong>.</p>\n<p>En Next.js, usamos archivos <code>.env.local</code> (para desarrollo) y <code>.env.production</code> (para producción). La regla de oro es: <strong>nunca se deben subir archivos <code>.env</code> con secretos (API keys, contraseñas de bases de datos) al repositorio de Git</strong>. Estos secretos se inyectan de forma segura en los entornos de staging y producción a través de las herramientas del proveedor de hosting (como Vercel, AWS, etc.) o desde el pipeline de CI/CD.</p>\n<p>Un pipeline de CI/CD bien configurado gestiona los despliegues a estos entornos. Por ejemplo, una fusión a la rama <code>develop</code> podría desplegar automáticamente a staging, mientras que una fusión a la rama <code>main</code> desplegaría a producción.</p>', duration: 60 },
    ],
    project: {
      title: 'App full stack dockerizada y desplegada',
      description: 'Contenerizar la aplicación completa en Docker y crear un pipeline de CI/CD con GitHub Actions para desplegarla automáticamente.',
    },
    quizId: 'quiz_5'
  },
   {
    id: '6',
    title: 'MÓDULO 6: Proyecto Intermedio',
    objective: 'Construir una app completa full-stack y desplegarla',
    classes: [],
    project: {
        title: 'Sistema de gestión de usuarios (CRUD, login, dashboard, etc.)',
        description: 'Entregable: Repositorio Git + Deploy en Render/Vercel + Documentación.<br/><br/><strong>Criterios de Evaluación:</strong><ul><li><strong>Correctitud Funcional:</strong> Cumplimiento de todos los requisitos (CRUD, auth, rutas protegidas).</li><li><strong>Calidad del Código (Front-End & Back-End):</strong> Arquitectura de componentes, uso correcto de Server/Client components, hooks, Server Actions/Route Handlers, legibilidad.</li><li><strong>Gestión de Versiones (Git/GitHub):</strong> Historial de commits limpio y semántico, README profesional.</li><li><strong>Despliegue (DevOps):</strong> App desplegada y accesible públicamente.</li></ul>',
    },
  },
  {
    id: '7',
    title: 'MÓDULO 7: Ciberseguridad para Desarrolladores Web',
    objective: 'Prevenir ataques y proteger aplicaciones web',
    classes: [
      { id: '7.1', title: 'Principios de ciberseguridad', content: '<h2>La Mentalidad del Desarrollador Seguro</h2>\n<p>La ciberseguridad no es una tarea que se realiza al final del desarrollo; es una <strong>mentalidad y una práctica continua</strong> que debe integrarse en cada línea de código que escribimos. Como desarrolladores, somos la primera y más importante línea de defensa de nuestras aplicaciones.</p>\n<h3>La Tríada de la CIA: Los Pilares de la Seguridad de la Información</h3>\n<p>Cualquier discusión sobre seguridad comienza con este modelo fundamental, conocido como la Tríada de la CIA (por sus siglas en inglés):</p>\n<ul>\n    <li><strong>Confidencialidad (Confidentiality):</strong> Asegurar que la información solo sea accesible para las personas autorizadas. Se trata de proteger los datos contra la divulgación no autorizada. <em>Ejemplo: Encriptar las contraseñas en la base de datos para que ni siquiera los administradores puedan leerlas.</em></li>\n    <li><strong>Integridad (Integrity):</strong> Garantizar que la información sea precisa y confiable, y que no pueda ser modificada de forma no autorizada. <em>Ejemplo: Usar firmas digitales o checksums para verificar que un archivo no ha sido alterado durante la transferencia.</em></li>\n    <li><strong>Disponibilidad (Availability):</strong> Asegurar que los sistemas y los datos estén operativos y accesibles para los usuarios autorizados cuando los necesiten. Se trata de proteger contra la interrupción del servicio. <em>Ejemplo: Protegerse contra ataques de Denegación de Servicio (DoS) que buscan sobrecargar un servidor para que deje de responder.</em></li>\n</ul>\n<h3>Principios Fundamentales para Escribir Código Seguro</h3>\n<p>Además de la tríada, varios principios guían el desarrollo seguro:</p>\n<ul>\n    <li><strong>Nunca Confiar en la Entrada del Usuario (Regla de Oro):</strong> Toda la información que proviene del cliente (formularios, parámetros de URL, headers) es potencialmente maliciosa. Siempre debe ser validada, saneada y/o codificada en el servidor antes de ser utilizada.</li>\n    <li><strong>Principio de Mínimo Privilegio:</strong> Cada usuario y cada componente del sistema debe tener solo los permisos estrictamente necesarios para realizar su función, y nada más. Un administrador no necesita ver la contraseña de un usuario; un script que muestra imágenes no necesita acceso a la base de datos.</li>\n    <li><strong>Defensa en Profundidad:</strong> La seguridad no debe depender de una única barrera. Se deben implementar múltiples capas de controles de seguridad (firewalls, autenticación, validación de entrada, encriptación). Si una capa falla, las otras pueden contener la amenaza.</li>\n    <li><strong>Seguridad por Defecto:</strong> Las configuraciones por defecto de una aplicación deben ser las más seguras posibles. El usuario debe optar explícitamente por configuraciones menos seguras si las necesita, no al revés.</li>\n</ul>\n<p>Adoptar estos principios como parte de tu flujo de trabajo diario es el primer paso para convertirte en un desarrollador que no solo crea funcionalidades, sino que también las protege.</p>', duration: 60 },
      { id: '7.2', title: 'OWASP Top 10', content: '<h2>El Mapa de las Amenazas: OWASP Top 10</h2>\n<p>El <strong>OWASP Top 10</strong> es el documento de referencia más importante en seguridad de aplicaciones web. No es una lista exhaustiva de todas las vulnerabilidades posibles, sino un documento de concienciación que destaca los 10 riesgos de seguridad más críticos y comunes, según los datos recopilados de miles de aplicaciones en el mundo real. Es, en esencia, el "mapa del tesoro" para los atacantes y, por lo tanto, la "lista de los más buscados" para nosotros, los desarrolladores.</p>\n<h3>¿Por Qué es Esencial?</h3>\n<ul>\n    <li><strong>Estándar de la Industria:</strong> Conocer y saber cómo mitigar los riesgos del OWASP Top 10 es una expectativa básica para cualquier rol de desarrollo web.</li>\n    <li><strong>Enfoque Práctico:</strong> Te permite centrar tus esfuerzos de seguridad en las áreas donde es más probable que ocurran ataques.</li>\n    <li><strong>Lenguaje Común:</strong> Proporciona una terminología estándar para discutir, documentar y remediar vulnerabilidades.</li>\n</ul>\n<h3>Un Vistazo a los Riesgos Más Críticos (Ejemplos del Top 10)</h3>\n<p>Aunque la lista se actualiza cada pocos años, algunas categorías son perennes. Las lecciones siguientes profundizarán en ellas, pero aquí hay un adelanto:</p>\n<ul>\n    <li><strong>A01:2021 - Control de Acceso Roto (Broken Access Control):</strong> La vulnerabilidad más común. Ocurre cuando un usuario puede acceder a datos o funcionalidades para las que no tiene permiso. Por ejemplo, un usuario normal que accede a un panel de administración simplemente cambiando la URL a <code>/admin</code>.</li>\n    <li><strong>A02:2021 - Fallas Criptográficas (Cryptographic Failures):</strong> Relacionado con la protección de datos sensibles como contraseñas, datos personales o información de tarjetas de crédito. Incluye no usar HTTPS o almacenar contraseñas en texto plano.</li>\n    <li><strong>A03:2021 - Inyección (Injection):</strong> Ocurre cuando datos no confiables proporcionados por el usuario se envían a un intérprete (como una base de datos SQL) como parte de un comando o consulta. Esto puede permitir a un atacante ejecutar comandos maliciosos.</li>\n    <li><strong>A05:2021 - Configuración de Seguridad Incorrecta (Security Misconfiguration):</strong> Errores como dejar puertos abiertos, tener mensajes de error demasiado detallados que revelan información del sistema, o usar credenciales por defecto (como `admin`/`admin`).</li>\n    <li><strong>A07:2021 - Fallas de Identificación y Autenticación (Identification and Authentication Failures):</strong> Errores en la lógica de inicio de sesión, gestión de sesiones o recuperación de contraseñas que permiten a un atacante hacerse pasar por un usuario legítimo.</li>\n</ul>\n<p>En las próximas lecciones, pasaremos de la teoría a la práctica y aprenderemos a identificar y neutralizar estas amenazas en nuestro código.</p>', duration: 90 },
      { id: '7.3', title: 'XSS, CSRF, SQL Injection', content: '<h2>El Trío Infame: Inyección, XSS y CSRF</h2>\n<p>Dentro del OWASP Top 10, hay tres vulnerabilidades tan clásicas y prevalentes que merecen su propia lección detallada. Entenderlas es fundamental para escribir código back-end seguro.</p>\n\n<h3>1. Inyección de SQL (SQL Injection)</h3>\n<p>Este ataque consiste en "inyectar" código SQL malicioso a través de una entrada de usuario (como un campo de formulario) para engañar a la base de datos y hacer que ejecute comandos no deseados, como eludir un inicio de sesión o robar datos.</p>\n<pre><code class="language-sql">\n-- Consulta vulnerable (NUNCA HACER ESTO)\nSELECT * FROM users WHERE username = \'\' + userInput + \'\' AND password = \'\' + passInput + \'\'\n\n-- Si un atacante introduce " \' OR \'1\'=\'1 " en ambos campos, la consulta se convierte en:\nSELECT * FROM users WHERE username = \'\' OR \'1\'=\'1\' AND password = \'\' OR \'1\'=\'1\'\n-- Esto siempre es verdadero y devuelve todos los usuarios, saltándose la autenticación.\n</code></pre>\n<p><strong>Prevención (La Regla de Oro):</strong> ¡Usa un ORM! Herramientas como <strong>Prisma</strong> (que conceptualizamos en el Módulo 4) resuelven este problema por diseño. Utilizan <strong>consultas parametrizadas (prepared statements)</strong>, que separan estrictamente la lógica de la consulta de los datos del usuario. Los datos nunca se interpretan como código SQL, neutralizando por completo esta amenaza.</p>\n\n<h3>2. Cross-Site Scripting (XSS)</h3>\n<p>En un ataque XSS, un atacante inyecta un script del lado del cliente (generalmente JavaScript) en páginas web vistas por otros usuarios. El script malicioso se ejecuta en el navegador de la víctima y puede robar sus cookies de sesión, credenciales o realizar acciones en su nombre.</p>\n<p><strong>Prevención (La Ventaja del Framework):</strong> La defensa principal contra XSS es la <strong>codificación de salida contextual (contextual output encoding)</strong>. La buena noticia es que <strong>React y Next.js hacen esto automáticamente</strong>. Cuando renderizas una variable en JSX (ej. <code>&lt;div&gt;{variableDelUsuario}&lt;/div&gt;</code>), React se asegura de que cualquier carácter potencialmente peligroso (como <code>&lt;</code>, <code>&gt;</code>) se convierta a su entidad de texto (<code>&amp;lt;</code>, <code>&amp;gt;</code>), por lo que el navegador lo muestra como texto y no lo ejecuta como código. Solo estarías en riesgo si usaras deliberadamente la prop <code>dangerouslySetInnerHTML</code> sin sanear la entrada primero.</p>\n\n<h3>3. Cross-Site Request Forgery (CSRF)</h3>\n<p>Este ataque engaña al navegador de una víctima autenticada para que envíe una petición HTTP no deseada a una aplicación en la que está conectada. Por ejemplo, un usuario podría visitar un sitio web malicioso que contiene una imagen oculta cuya URL es, en realidad, una petición a tu banco para transferir dinero: <code>&lt;img src="https://mibanco.com/transferir?a=atacante&cantidad=1000"&gt;</code>. Si el usuario tiene una sesión activa con su banco, el navegador enviará automáticamente las cookies de sesión y el banco procesará la transferencia.</p>\n<p><strong>Prevención (Tokens Anti-CSRF):</strong> La defensa estándar es el uso de <strong>tokens anti-CSRF</strong>. El servidor genera un token único y secreto para cada sesión de usuario y lo inserta en los formularios. Cuando se envía el formulario, el servidor comprueba que el token recibido coincide con el que generó. Como el sitio del atacante no puede adivinar este token, la petición falsificada falla. Frameworks como Next.js y librerías de autenticación a menudo incorporan mecanismos para mitigar esto, como el patrón "SameSite Cookies".</p>', duration: 90 },
      { id: '7.4', title: 'Seguridad en autenticación y JWT', content: '<h2>La Fortaleza de tu Aplicación: Autenticación Segura y Gestión de Sesiones</h2>\n<p>La autenticación no termina cuando el usuario introduce su contraseña. Gestionar la sesión y las credenciales de forma segura es igual de importante. Aquí es donde entran en juego los estándares modernos como JWT.</p>\n\n<h3>1. El Pecado Capital: Almacenar Contraseñas en Texto Plano</h3>\n<p>La regla número uno e inquebrantable de la seguridad de contraseñas es: <strong>NUNCA almacenes las contraseñas de los usuarios tal como las escriben</strong>. Si tu base de datos se ve comprometida, todas las cuentas quedarían expuestas instantáneamente.</p>\n<p>La solución es el <strong>hashing con sal (Salted Hashing)</strong>:</p>\n<ul>\n    <li><strong>Hashing:</strong> Es un proceso unidireccional que convierte la contraseña en una cadena de caracteres de longitud fija (el "hash"). Es imposible revertir el hash para obtener la contraseña original.</li>\n    <li><strong>Salting:</strong> Antes de hacer el hash, se añade una cadena aleatoria única (la "sal") a la contraseña. Esto asegura que incluso si dos usuarios tienen la misma contraseña, sus hashes almacenados serán diferentes, frustrando los ataques de "tablas arcoíris" (rainbow tables).</li>\n</ul>\n<p><strong>La buena noticia:</strong> ¡No tienes que implementar esto! Servicios como <strong>Firebase Authentication</strong> gestionan el hashing y salting de forma segura y automática, siguiendo las mejores prácticas de la industria. Usar un proveedor de identidad gestionado es siempre la opción recomendada.</p>\n\n<h3>2. JSON Web Tokens (JWT) para Sesiones sin Estado (Stateless)</h3>\n<p>Una vez que el usuario inicia sesión, ¿cómo lo mantenemos autenticado en las siguientes peticiones? El estándar moderno es el uso de <strong>JSON Web Tokens (JWT)</strong>.</p>\n<p>Un JWT es una cadena de texto compacta y segura que consta de tres partes separadas por puntos (<code>header.payload.signature</code>):</p>\n<ul>\n    <li><strong>Header:</strong> Contiene metadatos, como el tipo de token y el algoritmo de firma.</li>\n    <li><strong>Payload:</strong> Contiene las "reclamaciones" (claims), que son datos sobre el usuario (como su ID, su rol) y la expiración del token.</li>\n    <li><strong>Signature (Firma):</strong> Se crea combinando el header, el payload y una clave secreta que solo el servidor conoce. La firma garantiza que el token no ha sido manipulado. Si un atacante modifica el payload (por ejemplo, para cambiar su rol a "admin"), la firma ya no será válida.</li>\n</ul>\n<p>Cuando un cliente hace una petición a una ruta protegida, incluye el JWT en la cabecera <code>Authorization</code>. El servidor simplemente verifica la firma. Como no necesita almacenar nada sobre la sesión, se dice que es "stateless", lo cual es ideal para escalar aplicaciones.</p>\n\n<h3>3. Almacenamiento Seguro de JWT en el Cliente</h3>\n<p>¿Dónde guarda el navegador este token? Hay dos enfoques principales:</p>\n<ul>\n    <li><strong>Local Storage:</strong> Fácil de implementar, pero vulnerable a ataques XSS. Si un script malicioso se ejecuta en tu página, puede leer y robar el token del Local Storage.</li>\n    <li><strong>Cookies `HttpOnly` y `Secure`:</strong> Es el método más seguro. La cookie se configura con el flag `HttpOnly`, lo que impide que cualquier script de JavaScript pueda acceder a ella. El flag `Secure` asegura que la cookie solo se envíe a través de HTTPS. Este es el método preferido para mitigar el robo de tokens.</li>\n</ul>', duration: 120 },
      { id: '7.5', title: 'HTTPS, CORS, headers seguros', content: '<h2>La Infraestructura de la Confianza: HTTPS, CORS y Headers de Seguridad</h2>\n<p>La seguridad de una aplicación no solo reside en su código, sino también en cómo se comunica y cómo instruye al navegador para que se comporte de forma segura. Esta lección se centra en tres tecnologías fundamentales de la infraestructura web.</p>\n<h3>1. HTTPS (HTTP Secure): La Comunicación Encriptada</h3>\n<p>En la web moderna, <strong>HTTPS no es una opción, es una obligación</strong>. Si tu sitio maneja cualquier tipo de información, incluso si no es sensible, debe usar HTTPS. Este protocolo utiliza <strong>certificados SSL/TLS</strong> para crear un canal encriptado entre el navegador del usuario y tu servidor. Esto garantiza:</p>\n<ul>\n    <li><strong>Confidencialidad:</strong> Un atacante en la misma red (ej. una red Wi-Fi pública) no puede espiar los datos que se intercambian.</li>\n    <li><strong>Integridad:</strong> El atacante no puede modificar los datos en tránsito sin que la conexión se rompa.</li>\n    <li><strong>Autenticación:</strong> Verifica que te estás comunicando con el servidor correcto y no con un impostor.</li>\n</ul>\n<p>Afortunadamente, plataformas como Vercel o Netlify proporcionan certificados SSL gratuitos y los renuevan automáticamente, por lo que la implementación es muy sencilla.</p>\n<h3>2. CORS (Cross-Origin Resource Sharing)</h3>\n<p>Si alguna vez has visto un "error de CORS" en la consola del navegador, no estás viendo un error de tu código, sino una <strong>política de seguridad en acción</strong>. Por defecto, los navegadores aplican la <strong>Política del Mismo Origen (Same-Origin Policy)</strong>, que impide que una página web en `dominio-a.com` pueda leer datos de una API en `api.dominio-b.com`.</p>\n<p>CORS es el mecanismo que permite al servidor en `api.dominio-b.com` "relajar" esta política de forma controlada. Mediante el envío de cabeceras HTTP especiales (como <code>Access-Control-Allow-Origin</code>), el servidor puede decirle al navegador: "Confío en `dominio-a.com` y le permito acceder a mis datos". Es una medida de seguridad crucial para proteger las APIs.</p>\n<h3>3. Cabeceras de Seguridad (Security Headers)</h3>\n<p>Tu servidor puede enviar cabeceras HTTP que son directivas para el navegador del usuario, indicándole cómo debe comportarse para mejorar la seguridad. Algunas de las más importantes son:</p>\n<ul>\n    <li><strong><code>Strict-Transport-Security</code> (HSTS):</strong> Una vez que un usuario visita tu sitio por HTTPS, esta cabecera le dice al navegador que, durante un tiempo determinado, cualquier intento futuro de visitar el sitio por HTTP debe ser convertido automáticamente a HTTPS.</li>\n    <li><strong><code>Content-Security-Policy</code> (CSP):</strong> Es una de las defensas más potentes contra XSS. Te permite definir una "lista blanca" de fuentes de las que el navegador tiene permitido cargar recursos (scripts, estilos, imágenes). Si un atacante inyecta un script desde un dominio no autorizado, el navegador simplemente lo bloqueará.</li>\n    <li><strong><code>X-Frame-Options</code> o <code>frame-ancestors</code> en CSP:</strong> Impide que tu sitio web sea incrustado en un <code>&lt;iframe&gt;</code> en otra página. Esto te protege de un ataque llamado "clickjacking", donde un atacante muestra tu sitio en un iframe invisible y engaña al usuario para que haga clic en botones sensibles (como "eliminar cuenta") sin darse cuenta.</li>\n</ul>', duration: 120 },
      { id: '7.6', title: 'Hardening de aplicaciones', content: '<h2>La Capa Final de Defensa: Fortalecimiento (Hardening)</h2>\n<p>El "hardening" es un término amplio que se refiere a reducir la "superficie de ataque" de tu aplicación. Consiste en aplicar una serie de configuraciones y prácticas defensivas para hacer que sea lo más difícil posible para un atacante encontrar y explotar una vulnerabilidad. No se trata de una única acción, sino de una mentalidad de seguridad proactiva.</p>\n<h3>Prácticas Clave de Hardening</h3>\n<ul>\n    <li><strong>Minimizar la Superficie de Ataque:</strong> Esto implica deshabilitar cualquier funcionalidad, módulo o puerto que no sea estrictamente necesario para el funcionamiento de la aplicación. Cuanto menos código esté expuesto, menos vulnerabilidades potenciales existen.</li>\n    <li><strong>Gestión de Dependencias Segura:</strong> Las vulnerabilidades en las librerías de terceros son una de las principales vías de ataque. Es crucial escanear regularmente tus dependencias en busca de vulnerabilidades conocidas utilizando herramientas como <code>npm audit</code> o Snyk, y mantenerlas actualizadas.</li>\n    <li><strong>Manejo de Errores Seguro:</strong> Los mensajes de error en producción nunca deben filtrar información sensible sobre la infraestructura, como trazas de la pila (stack traces), nombres de bases de datos o rutas de archivos. Los errores deben ser genéricos para el usuario (ej. "Ha ocurrido un error inesperado") pero registrar toda la información detallada en un sistema de logging seguro para los desarrolladores.</li>\n    <li><strong>Logging y Monitorización de Seguridad:</strong> Debes registrar eventos relevantes para la seguridad, como inicios de sesión fallidos, intentos de acceso a recursos no autorizados o errores de validación repetidos. Esto te permite detectar patrones sospechosos que podrían indicar un ataque en curso y ayuda en el análisis forense si ocurre un incidente.</li>\n    <li><strong>Principio de Mínimo Privilegio (Revisado):</strong> Asegúrate de que el proceso de tu aplicación se ejecuta con los mínimos permisos necesarios en el servidor. Por ejemplo, no debería ejecutarse como usuario `root`.</li>\n</ul>\n<p>El hardening es el proceso de aplicar diligentemente todas las capas de seguridad que hemos discutido, creando una aplicación que no solo funciona bien, sino que también es resistente por diseño.</p>', duration: 60 },
    ],
    project: {
      title: 'Análisis y hardening de una app',
      description: 'Realizar un análisis de seguridad de una aplicación y aplicar las mejoras necesarias.',
    },
    quizId: 'quiz_7',
  },
   {
    id: '8',
    title: 'MÓDULO 8: Introducción a la Inteligencia Artificial',
    objective: 'Aplicar IA a productos web',
    classes: [
      { id: '8.1', title: '¿Qué es IA y cómo se usa en la web?', content: '<h2>La Nueva Frontera del Desarrollo Web: Inteligencia Artificial</h2>\n<p>Lejos de ser un concepto de ciencia ficción, la <strong>Inteligencia Artificial (IA)</strong> se ha convertido en una herramienta práctica y accesible que está redefiniendo lo que es posible en la web. Para un desarrollador, la IA no es un reemplazo, sino un <strong>multiplicador de fuerza</strong> que permite crear aplicaciones más inteligentes, personalizadas y eficientes.</p>\n<h3>Desmitificando la IA: ¿Qué es Realmente?</h3>\n<p>En el contexto del desarrollo web, podemos definir la IA como la capacidad de un sistema para <strong>aprender de los datos y tomar decisiones o realizar predicciones</strong> para lograr un objetivo específico, sin haber sido programado explícitamente para cada escenario posible.</p>\n<ul>\n    <li><strong>Machine Learning (ML):</strong> Es el subcampo de la IA que nos concierne directamente. Se trata de algoritmos que "aprenden" patrones a partir de grandes cantidades de datos.</li>\n    <li><strong>Deep Learning:</strong> Es una técnica avanzada de Machine Learning que utiliza "redes neuronales" con muchas capas. Es el motor detrás de las revoluciones recientes, como los modelos de lenguaje grandes (LLMs).</li>\n</ul>\n<h3>La Revolución de las APIs de IA</h3>\n<p>La mayor barrera para usar IA solía ser la necesidad de profundos conocimientos matemáticos y una enorme capacidad de cómputo para entrenar modelos. <strong>Esto ha cambiado radicalmente</strong>. Hoy, podemos integrar capacidades de IA de vanguardia en nuestras aplicaciones a través de <strong>APIs</strong>, de la misma forma que usamos cualquier otro servicio de terceros.</p>\n<p>Plataformas como <strong>Google (con Genkit y los modelos Gemini)</strong>, OpenAI y otras, nos permiten enviar una petición con nuestros datos (ej. una pregunta de un usuario) y recibir una respuesta inteligente generada por un modelo preentrenado masivo. Esto abre un mundo de posibilidades.</p>\n<h3>Casos de Uso Prácticos en la Web Moderna</h3>\n<p>Como desarrolladores web, podemos usar IA para:</p>\n<ul>\n    <li><strong>Crear Chatbots y Asistentes:</strong> Ofrecer soporte 24/7 o guiar a los usuarios a través de procesos complejos.</li>\n    <li><strong>Generar Contenido Dinámico:</strong> Crear descripciones de productos, resúmenes de artículos o incluso código.</li>\n    <li><strong>Personalizar la Experiencia de Usuario:</strong> Recomendar productos o contenido basándose en el comportamiento del usuario.</li>\n    <li><strong>Análisis de Sentimientos:</strong> Entender la opinión de los usuarios a partir de comentarios o reseñas.</li>\n    <li><strong>Moderación de Contenido:</strong> Filtrar automáticamente spam o contenido inapropiado.</li>\n    <li><strong>Mejorar la Accesibilidad:</strong> Generar descripciones de imágenes (texto alternativo) automáticamente.</li>\n</ul>\n<p>En este módulo, nos centraremos en el uso práctico de estas APIs a través de herramientas como <strong>Genkit</strong>, la librería oficial de Google para construir flujos de IA, permitiéndonos integrar estas capacidades de forma estructurada y segura en nuestras aplicaciones Next.js.</p>', duration: 60 },
      { id: '8.2', title: 'El Ecosistema de Genkit y los Modelos Gemini', content: '<h2>Herramientas para el Desarrollador de IA: Genkit y Gemini</h2>\n<p>Para integrar IA en nuestra aplicación Next.js, no necesitamos reinventar la rueda ni convertirnos en expertos en Python. Utilizaremos herramientas modernas diseñadas para desarrolladores de TypeScript: <strong>Genkit</strong> y los modelos <strong>Gemini</strong> de Google.</p>\n<h3>¿Qué es Genkit?</h3>\n<p><strong>Genkit</strong> es un framework de código abierto de Google diseñado para simplificar la construcción, el despliegue y la monitorización de aplicaciones de IA. Piensa en él como un "Next.js" para la IA: proporciona una estructura y un conjunto de herramientas para organizar tu código de IA de manera eficiente.</p>\n<p>Sus principales ventajas son:</p>\n<ul>\n    <li><strong>Hecho para TypeScript:</strong> Se integra perfectamente en nuestro stack tecnológico existente.</li>\n    <li><strong>Organización y Estructura:</strong> Introduce conceptos como <strong>Flows (Flujos)</strong> para encapsular la lógica de IA, haciendo que el código sea mantenible y fácil de probar.</li>\n    <li><strong>Portabilidad de Modelos:</strong> Aunque lo usaremos con los modelos de Google, Genkit está diseñado para que puedas cambiar de proveedor de modelos (como OpenAI o Anthropic) con cambios mínimos en tu código.</li>\n    <li><strong>Observabilidad:</strong> Ofrece herramientas integradas para trazar y depurar las ejecuciones de tus flujos, permitiéndote ver exactamente qué está pasando en cada paso de tu lógica de IA.</li>\n</ul>\n<h3>Los Bloques de Construcción en Genkit</h3>\n<p>Al trabajar con Genkit, te encontrarás con estos conceptos clave, que ya hemos visto en nuestra aplicación:</p>\n<ul>\n    <li><strong>Flows:</strong> Son el corazón de tu lógica de IA. Un `flow` es una función que puedes llamar desde tu aplicación y que orquesta las llamadas a los modelos, el procesamiento de datos y la interacción con otras herramientas. Nuestros archivos en <code>src/ai/flows/</code> son ejemplos perfectos.</li>\n    <li><strong>Prompts:</strong> Son las instrucciones que le damos al modelo. Genkit nos permite definir prompts de forma estructurada, separándolos del código de la aplicación y facilitando su gestión.</li>\n    <li><strong>Models (Modelos Gemini):</strong> El "cerebro" que ejecuta nuestras instrucciones. Usaremos la familia de modelos <strong>Gemini</strong>, los modelos de IA multimodales de última generación de Google, capaces de entender y procesar texto, imágenes, audio y vídeo.</li>\n    <li><strong>Tools (Herramientas):</strong> Permiten que tu IA sea más que un simple generador de texto. Una "herramienta" es una función que el modelo puede decidir llamar para obtener información del mundo real (ej. buscar en tu base de datos, consultar el precio de un producto en una API externa) y así dar respuestas más precisas y contextualizadas.</li>\n</ul>\n<h3>Nuestra Configuración Actual</h3>\n<p>En <code>src/ai/genkit.ts</code>, ya tenemos la configuración básica de Genkit. Se inicializa el framework y se carga el plugin <code>googleAI()</code>, que nos da acceso a toda la potencia de los modelos Gemini directamente desde nuestro código TypeScript. Este es el punto de partida para construir cualquier funcionalidad de IA en nuestro curso.</p>', duration: 90 },
      { id: '8.3', title: 'Construyendo un Flow con Genkit: De la Idea al Código', content: '<h2>Manos a la Obra: La Anatomía de un Flow de IA</h2>\n<p>Ahora que entendemos qué son Genkit y Gemini, es hora de construir. Un <strong>Flow</strong> de Genkit es más que una simple llamada a una API; es una receta estructurada que garantiza que nuestras interacciones con la IA sean predecibles, seguras y mantenibles. Vamos a desglosar sus componentes esenciales, usando el flow para generar resúmenes (`summarize-lesson.ts`) como ejemplo.</p>\n<h3>1. El Contrato: Schemas de Entrada y Salida con Zod</h3>\n<p>Antes de escribir cualquier lógica de IA, definimos un contrato claro. ¿Qué datos necesita nuestro flow y qué datos debe devolver? Para esto, usamos <strong>Zod</strong>, una librería que nos permite definir esquemas de datos en TypeScript.</p>\n<ul>\n    <li><strong>Input Schema (Esquema de Entrada):</strong> Define la "forma" de los datos que el flow espera recibir. En nuestro flow de resumen, el input es un objeto con una propiedad `lessonContent` de tipo `string`. Esto nos da seguridad de tipos y validación automática.</li>\n    <li><strong>Output Schema (Esquema de Salida):</strong> Define la estructura de la respuesta que <strong>le exigimos al modelo</strong>. En lugar de recibir texto libre, le pedimos al modelo que nos devuelva un objeto JSON con una propiedad `summary`. Esto es increíblemente potente, ya que transforma al LLM en un generador de datos estructurados y fiables que nuestra aplicación puede consumir fácilmente.</li>\n</ul>\n\n<h3>2. La Instrucción: Prompt Engineering Básico</h3>\n<p>El <strong>prompt</strong> es la instrucción que le damos al modelo. Un buen prompt es claro, específico y le da al modelo un "rol" y un contexto. En nuestro ejemplo de resumen:</p>\n<ul>\n    <li><strong>Rol:</strong> "Eres un experto educador y content summarizer".</li>\n    <li><strong>Tarea:</strong> "Genera un resumen conciso y atractivo".</li>\n    <li><strong>Contexto y Formato:</strong> "Dado el siguiente contenido de la lección (en HTML)... El resumen debe ser texto plano".</li>\n    <li><strong>Inyección de Datos:</strong> Usamos la sintaxis `{{lessonContent}}` para insertar dinámicamente el contenido de la lección en el prompt.</li>\n</ul>\n<p>La combinación del prompt y el `outputSchema` obliga al modelo a comportarse como una función predecible.</p>\n\n<h3>3. La Orquestación: El Flow</h3>\n<p>Finalmente, el <strong>flow</strong> de Genkit une todas las piezas. Es una función asíncrona que:</p>\n<ol>\n    <li>Recibe un objeto de entrada que coincide con el `inputSchema`.</li>\n    <li>Llama al prompt definido, pasándole la entrada. Genkit se encarga de la comunicación con la API de Gemini.</li>\n    <li>Recibe la respuesta del modelo, que ya viene parseada y validada según nuestro `outputSchema`.</li>\n    <li>Devuelve el resultado estructurado.</li>\n</ol>\n<p>Al seguir esta estructura, creamos componentes de IA que son modulares, fáciles de probar y seguros, sentando las bases para construir aplicaciones de IA complejas de manera robusta.</p>', duration: 90 },
      { id: '8.4', title: 'Procesamiento de lenguaje natural (NLP)', content: '<h2>Ampliando Horizontes: Tareas Prácticas de NLP con Genkit</h2>\n<p>El <strong>Procesamiento de Lenguaje Natural (NLP)</strong> es el campo de la IA que se ocupa de dar a las computadoras la capacidad de entender, interpretar y generar lenguaje humano. Aunque suena complejo, la buena noticia es que los modernos Modelos de Lenguaje Grandes (LLMs) como Gemini han hecho que la aplicación de tareas de NLP sea más accesible que nunca. No necesitamos entender la lingüística computacional subyacente; solo necesitamos saber cómo pedirle al modelo que realice la tarea.</p>\n<h3>La Revolución de los LLMs en el NLP</h3>\n<p>Tradicionalmente, las tareas de NLP requerían pasos complejos de pre-procesamiento (tokenización, lematización, etc.) y modelos específicos para cada tarea. Hoy en día, un solo LLM bien instruido puede realizar una multitud de tareas de NLP, a menudo con solo cambiar el prompt. Como desarrolladores, nuestro trabajo se ha desplazado de la ingeniería de datos a la <strong>ingeniería de prompts</strong>.</p>\n<h3>Tareas de NLP que Podemos Implementar Fácilmente</h3>\n<p>Con Genkit y un esquema de salida Zod bien definido, podemos instruir a Gemini para que realice una variedad de tareas avanzadas:</p>\n<ul>\n    <li><strong>Análisis de Sentimientos:</strong> Dado un comentario de un usuario, podemos pedirle al modelo que lo clasifique como "positivo", "negativo" o "neutral". Esto es increíblemente útil para analizar feedback a escala.</li>\n    <li><strong>Extracción de Entidades (Named Entity Recognition - NER):</strong> Podemos proporcionar un texto largo (como un artículo de noticias) y pedirle al modelo que extraiga todas las menciones de personas, organizaciones, lugares o fechas, y que las devuelva en un array de objetos JSON.</li>\n    <li><strong>Clasificación de Texto (Topic Modeling):</strong> Analizar un bloque de texto y pedir al modelo que le asigne una o varias categorías de una lista predefinida. Útil para organizar automáticamente contenido.</li>\n    <li><strong>Respuesta a Preguntas (Q&A):</strong> Darle al modelo un texto de contexto largo (como una página de la documentación) y luego hacerle una pregunta. El modelo puede encontrar y formular una respuesta basada únicamente en el contexto proporcionado, como lo hace nuestro flow de búsqueda en el curso.</li>\n    <li><strong>Traducción:</strong> Aunque existen servicios dedicados, un LLM puede realizar traducciones de alta calidad con un simple prompt.</li>\n</ul>\n<p>La clave del éxito en todas estas tareas es la misma que ya hemos aprendido: un <strong>prompt claro</strong> que defina el rol y la tarea, y un <strong>outputSchema de Zod</strong> que fuerce al modelo a devolver una respuesta estructurada y predecible que nuestra aplicación pueda utilizar.</p>', duration: 120 },
      { id: '8.5', title: 'Aplicaciones prácticas: chatbot con IA', content: '<h2>Construyendo el Asistente del Futuro: Chatbots con IA</h2>\n<p>Una de las aplicaciones más populares y potentes de los Modelos de Lenguaje Grandes es la creación de <strong>interfaces conversacionales o chatbots</strong>. Esta lección une todos los conceptos que hemos aprendido en el módulo para construir un producto final tangible.</p>\n<h3>1. Arquitectura de un Chatbot Básico</h3>\n<p>Un chatbot se compone de tres partes principales:</p>\n<ul>\n    <li><strong>La Interfaz de Usuario (UI):</strong> Un componente de React que muestra el historial de mensajes y un campo de entrada para que el usuario escriba.</li>\n    <li><strong>La Gestión de Estado (Cliente):</strong> Un estado de React (usando <code>useState</code>) que almacena un array de mensajes. Cada vez que se añade un mensaje nuevo (del usuario o de la IA), el estado se actualiza y la UI se vuelve a renderizar.</li>\n    <li><strong>El Backend de IA (Genkit Flow):</strong> Un flujo de Genkit que recibe la conversación y genera la siguiente respuesta.</li>\n</ul>\n<h3>2. El Concepto Clave: La Memoria es un Bucle</h3>\n<p>Los LLMs son "stateless", lo que significa que no recuerdan interacciones pasadas por sí mismos. Para que un chatbot mantenga una conversación coherente, debemos implementar la memoria nosotros mismos. El truco es simple pero fundamental: <strong>con cada nuevo mensaje del usuario, debemos enviar todo el historial de la conversación anterior junto con el nuevo mensaje al modelo</strong>. Esto le da al LLM el contexto completo para formular una respuesta relevante.</p>\n<h3>3. El Flow de Genkit para un Chat</h3>\n<p>El `flow` para un chatbot tendría una estructura como esta:</p>\n<ul>\n    <li><strong>Input Schema (Zod):</strong> Aceptaría un array de objetos de mensajes (cada uno con un `role` - "user" o "model" - y `content`) y el nuevo mensaje del usuario.</li>\n    <li><strong>Prompt:</strong> La instrucción sería algo como: "Eres un asistente servicial. Continúa la siguiente conversación, respondiendo al último mensaje del usuario en el contexto del historial".</li>\n    <li><strong>Lógica:</strong> El flow combinaría el historial con el nuevo mensaje, llamaría al modelo con el prompt, y devolvería la respuesta de la IA.</li>\n</ul>\n<h3>4. Mejorando la Experiencia: Streaming de Respuestas</h3>\n<p>Para evitar que el usuario espere a que se genere la respuesta completa, podemos usar <strong>streaming</strong>. Genkit y los modelos Gemini soportan esto. Permite que la respuesta de la IA se envíe al cliente token por token, apareciendo en la pantalla palabra por palabra, similar a la experiencia en ChatGPT. Esto mejora drásticamente la sensación de interactividad.</p>', duration: 120 },
    ],
    project: {
      title: 'Web app con integración de IA',
      description: 'Crear una aplicación web que integre una funcionalidad de IA, como un asistente o un sistema de recomendaciones.',
    },
    quizId: 'quiz_8',
  },
  {
    id: '9',
    title: 'MÓDULO 9: Web3 y Blockchain',
    objective: 'Entender la web descentralizada y crear apps sobre blockchain',
    classes: [
      { id: '9.1', title: 'Fundamentos de Web3 y contratos inteligentes', content: '<h2>La Próxima Evolución de Internet: Introducción a la Web3</h2>\n<p>Hemos viajado desde una web de solo lectura (Web1) a una web interactiva y dominada por plataformas (Web2). La <strong>Web3</strong> representa la siguiente fase: una web descentralizada construida sobre los principios de la tecnología blockchain, la transparencia y la propiedad del usuario.</p>\n<h3>De la Web2 a la Web3: El Cambio de Paradigma</h3>\n<ul>\n    <li><strong>Web2 (La Web Actual):</strong> Interactuamos a través de plataformas centralizadas (Google, Facebook, etc.). Estas empresas controlan nuestros datos y las reglas de la plataforma. Es una web de <em>lectura y escritura</em>.</li>\n    <li><strong>Web3 (La Web Emergente):</strong> La propiedad y el control se devuelven a los usuarios. Las aplicaciones (dApps) se ejecutan en redes descentralizadas (blockchains), no en servidores de una sola empresa. Es una web de <em>lectura, escritura y propiedad</em> (read-write-own).</li>\n</ul>\n<h3>Los Pilares Tecnológicos de la Web3</h3>\n<ol>\n    <li><strong>Blockchain: El Libro Contable Inmutable:</strong> Es la tecnología central. Una blockchain es una base de datos distribuida y criptográficamente segura. Una vez que se añade un dato ("bloque"), no se puede modificar ni eliminar, creando un registro permanente y transparente de todas las transacciones.</li>\n    <li><strong>Criptomonedas: El Incentivo Económico:</strong> Son los activos nativos (como Ether en Ethereum) que se utilizan para pagar las operaciones en la red y para incentivar a los participantes a mantenerla segura y funcionando.</li>\n    <li><strong>Contratos Inteligentes (Smart Contracts): El Código es Ley:</strong> Este es el concepto más revolucionario para los desarrolladores. Un contrato inteligente es un programa que se almacena y se ejecuta en la blockchain. Se autoejecuta cuando se cumplen condiciones predefinidas, sin necesidad de intermediarios. Es un código transparente, inmutable y determinista.</li>\n</ol>\n<h3>Ethereum: La Computadora Mundial Programable</h3>\n<p>Mientras que Bitcoin fue la primera blockchain (diseñada principalmente como dinero digital), <strong>Ethereum</strong> fue la que introdujo la idea de una <strong>blockchain programable</strong> a través de los contratos inteligentes. Esto transformó la blockchain de un simple libro de contabilidad a una especie de "computadora mundial" descentralizada, sobre la cual cualquiera puede construir aplicaciones (dApps) que son resistentes a la censura y no están controladas por una única entidad. La gran mayoría del ecosistema Web3 actual está construido sobre Ethereum o redes compatibles.</p>', duration: 60 },
      { id: '9.2', title: 'Wallets y redes blockchain', content: '<h2>Herramientas Esenciales para Operar en Web3</h2>\n<p>Para interactuar con la Web3, los usuarios y desarrolladores necesitan herramientas especializadas que gestionen su identidad y sus activos de forma segura en la blockchain. Esta lección cubre los componentes prácticos que hacen posible la interacción.</p>\n<h3>1. La Wallet: Tu Identidad Digital</h3>\n<p>Una <strong>wallet (o cartera) de criptomonedas</strong> no almacena tus activos directamente como una cartera física. En cambio, es una interfaz de software (como una extensión de navegador o una aplicación móvil) que guarda y gestiona tus <strong>claves criptográficas</strong>. Es tu puerta de entrada a la Web3, permitiéndote:</p>\n<ul>\n    <li><strong>Autenticarte</strong> en aplicaciones descentralizadas (dApps) sin necesidad de usuario y contraseña.</li>\n    <li><strong>Firmar y autorizar transacciones</strong> de forma segura.</li>\n    <li><strong>Consultar tus saldos</strong> de criptomonedas y NFTs.</li>\n</ul>\n<p>La wallet más popular y el estándar de facto para el desarrollo en Ethereum y redes compatibles es <strong>MetaMask</strong>.</p>\n<h3>2. Claves Públicas y Privadas: La Base de la Propiedad</h3>\n<p>Cada wallet gestiona un par de claves criptográficas que son matemáticamente inseparables:</p>\n<ul>\n    <li><strong>Clave Pública:</strong> Se deriva de tu clave privada y se utiliza para generar tu dirección de wallet (por ejemplo, <code>0x123...abc</code>). Es como tu número de cuenta bancaria o tu correo electrónico; puedes compartirla de forma segura para recibir activos.</li>\n    <li><strong>Clave Privada:</strong> Es el secreto que prueba que eres el propietario de los activos asociados a tu dirección. Es como la contraseña maestra de tu vida digital. <strong>Quien tiene la clave privada, tiene el control total. Nunca, bajo ninguna circunstancia, debe ser compartida o expuesta.</strong></li>\n</ul>\n<h3>3. Mainnet vs. Testnets: El Campo de Juego y el Gimnasio</h3>\n<p>No se puede desarrollar directamente en la red principal (<strong>Mainnet</strong>) de Ethereum, ya que cada transacción cuesta dinero real. Para esto existen las <strong>Testnets (redes de prueba)</strong>.</p>\n<ul>\n    <li><strong>Mainnet:</strong> La red de producción real de Ethereum, donde las transacciones tienen valor económico real.</li>\n    <li><strong>Testnets (ej. Sepolia):</strong> Son clones de la Mainnet que funcionan en paralelo. El Ether en estas redes no tiene valor real, lo que permite a los desarrolladores desplegar, probar y depurar sus contratos inteligentes de forma gratuita y sin riesgos. Puedes obtener Ether de prueba de sitios web llamados "faucets".</li>\n</ul>\n<h3>4. Gas: El Combustible de la Blockchain</h3>\n<p>Cada operación que modifica el estado de la blockchain (como enviar Ether o ejecutar una función de un contrato inteligente) requiere un esfuerzo computacional por parte de la red. Esta operación se llama <strong>transacción</strong>, y su coste se mide en una unidad llamada <strong>gas</strong>. Para ejecutar una transacción, el usuario debe pagar una "tarifa de gas" en la criptomoneda nativa de la red (Ether). Esto sirve para dos propósitos: compensar a los validadores que mantienen la red segura y prevenir el spam de transacciones maliciosas.</p>', duration: 90 },
      { id: '9.3', title: 'Smart contracts con Solidity', content: '<h2>El Lenguaje de la Blockchain: Programando con Solidity</h2>\n<p>Si los contratos inteligentes son los programas que se ejecutan en la blockchain, <strong>Solidity</strong> es el lenguaje de programación principal que usamos para escribirlos. Creado por el equipo de Ethereum, es un lenguaje de alto nivel, orientado a objetos y de tipado estático, cuya sintaxis resultará familiar para cualquiera que conozca JavaScript, C++ o Java.</p>\n<h3>1. El Entorno de Desarrollo: Remix IDE</h3>\n<p>Para empezar a escribir Solidity, no necesitamos instalar nada. Usaremos <strong>Remix IDE</strong>, un potente entorno de desarrollo integrado que funciona directamente en el navegador. Remix nos permite escribir, compilar, desplegar y probar nuestros contratos de manera rápida y visual, lo que lo convierte en la herramienta perfecta para aprender.</p>\n<h3>2. La Anatomía de un Contrato Simple</h3>\n<p>Veamos la estructura de un contrato básico que almacena y recupera un número. Es el "Hola, Mundo" de los contratos inteligentes.</p>\n<pre><code class="language-solidity">\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract SimpleStorage {\n    // Variable de estado: su valor se almacena permanentemente en la blockchain.\n    uint256 private favoriteNumber;\n\n    // Función para escribir datos en la blockchain (modifica el estado).\n    // Cuesta gas ejecutarla.\n    function store(uint256 _newNumber) public {\n        favoriteNumber = _newNumber;\n    }\n\n    // Función para leer datos de la blockchain (no modifica el estado).\n    // Es gratuita (no cuesta gas) si se llama externamente.\n    // La palabra clave `view` indica que solo lee el estado.\n    function retrieve() public view returns (uint256) {\n        return favoriteNumber;\n    }\n}\n</code></pre>\n<h3>Conceptos Fundamentales en el Código</h3>\n<ul>\n    <li><strong><code>pragma solidity ^0.8.20;</code>:</strong> Le dice al compilador qué versión de Solidity usar.</li>\n    <li><strong><code>contract SimpleStorage { ... }</code>:</strong> Define el contrato, similar a una clase en otros lenguajes.</li>\n    <li><strong><code>uint256 favoriteNumber;</code>:</strong> Declara una variable de estado, un entero sin signo de 256 bits. Este es el tipo de dato estándar para números en Solidity.</li>\n    <li><strong>Funciones (`store`, `retrieve`):</strong> Son los bloques de código ejecutables. La función <code>store</code> es una <strong>transacción de escritura</strong>, mientras que <code>retrieve</code> es una <strong>transacción de lectura</strong>.</li>\n    <li><strong>Visibilidad (`public`, `private`):</strong> Controla quién puede llamar a las funciones o acceder a las variables.</li>\n</ul>\n<p>Este simple contrato encapsula los principios más importantes del desarrollo en Solidity: la persistencia de datos en variables de estado y la ejecución de lógica a través de funciones.</p>', duration: 90 },
      { id: '9.4', title: 'DApps con React + Web3.js', content: '<h2>Uniendo Dos Mundos: La Aplicación Descentralizada (dApp)</h2>\n<p>Una <strong>dApp</strong> no es más que una aplicación front-end (como las que hemos construido con React) que se comunica con un back-end descentralizado (nuestro contrato inteligente en la blockchain) en lugar de un servidor centralizado.</p>\n<h3>La Arquitectura de una dApp</h3>\n<p>El stack tecnológico cambia ligeramente:</p>\n<ul>\n    <li><strong>Front-End (React/Next.js):</strong> La interfaz de usuario que ya conocemos.</li>\n    <li><strong>Wallet (MetaMask):</strong> Actúa como el puente entre nuestra dApp y la blockchain. Es el proveedor de identidad y el firmante de transacciones del usuario.</li>\n    <li><strong>Librería Web3 (Ethers.js):</strong> Es la librería de JavaScript que permite a nuestro código front-end comunicarse con la blockchain. Con Ethers.js, podemos leer datos del contrato, formatear transacciones y enviarlas a MetaMask para que el usuario las firme.</li>\n    <li><strong>Nodo RPC (Infura/Alchemy):</strong> Nuestra dApp no se conecta a toda la red de Ethereum directamente. En su lugar, se comunica a través de un nodo mediante un protocolo llamado RPC. Servicios como Infura o Alchemy nos proporcionan acceso a nodos de Ethereum de alto rendimiento sin que tengamos que gestionar la infraestructura nosotros mismos.</li>\n</ul>\n<h3>El Flujo de Interacción Típico</h3>\n<ol>\n    <li>El usuario llega a nuestra dApp. Nuestro código React, usando Ethers.js, detecta si MetaMask está instalado.</li>\n    <li>Hacemos clic en un botón "Conectar Wallet". Esto abre una petición en MetaMask para que el usuario apruebe la conexión.</li>\n    <li>Una vez conectado, nuestro código puede leer la dirección de la wallet del usuario y consultar datos públicos del contrato (por ejemplo, llamar a la función `retrieve()` de nuestro `SimpleStorage`).</li>\n    <li>Cuando el usuario quiere realizar una acción que modifica el estado (como llamar a la función `store()`), nuestro código crea la transacción y se la pasa a MetaMask.</li>\n    <li>MetaMask muestra una ventana emergente al usuario con los detalles de la transacción (incluyendo la tarifa de gas estimada) y le pide que la confirme o rechace.</li>\n    <li>Si el usuario confirma, MetaMask firma la transacción con la clave privada del usuario y la envía a la red.</li>\n</ol>\n<p>Este proceso asegura que la clave privada nunca abandone la wallet del usuario, proporcionando un modelo de seguridad robusto donde el usuario siempre tiene el control final sobre sus activos y acciones.</p>', duration: 120 },
      { id: '9.5', title: 'NFT y marketplaces', content: '<h2>La Propiedad Digital Verificable: NFTs y sus Mercados</h2>\n<p>Un <strong>NFT (Token No Fungible)</strong> es una de las aplicaciones más conocidas de la tecnología blockchain. Es un tipo especial de token criptográfico que representa la propiedad de un activo único, ya sea digital o físico. A diferencia de las criptomonedas como el Ether, que son fungibles (cada Ether es idéntico a otro), cada NFT es único e irrepetible.</p>\n<h3>El Estándar ERC-721: El Lenguaje Común de los NFTs</h3>\n<p>La razón por la que los NFTs funcionan de manera interoperable en todo el ecosistema de Ethereum se debe al estándar de contrato inteligente <strong>ERC-721</strong>. Este estándar es una interfaz (un conjunto de reglas y funciones) que todo contrato de NFT debe implementar. Algunas de sus funciones clave son:</p>\n<ul>\n    <li><strong><code>ownerOf(tokenId)</code>:</strong> Devuelve la dirección del propietario de un NFT específico.</li>\n    <li><strong><code>balanceOf(owner)</code>:</strong> Devuelve cuántos NFTs de esa colección posee una dirección.</li>\n    <li><strong><code>transferFrom(from, to, tokenId)</code>:</strong> Permite transferir la propiedad de un NFT.</li>\n</ul>\n<p>Al adherirse a este estándar, cualquier dApp, wallet o marketplace puede leer quién es el dueño de un NFT y facilitar su transferencia, sin necesidad de conocer los detalles internos de cada colección específica.</p>\n<h3>Metadatos: La Conexión entre el Token y el Arte</h3>\n<p>El contrato inteligente en la blockchain no almacena la imagen, el vídeo o la canción directamente (sería extremadamente caro y poco práctico). Lo que se almacena en el contrato es un <strong>identificador de token (Token ID)</strong> único y una función (<code>tokenURI(tokenId)</code>) que devuelve una URL.</p>\n<p>Esta URL apunta a un archivo <strong>JSON de metadatos</strong>. Es este archivo, alojado generalmente en un sistema de almacenamiento descentralizado como <strong>IPFS (InterPlanetary File System)</strong>, el que contiene toda la información sobre el activo:</p>\n<ul>\n    <li>El nombre del NFT.</li>\n    <li>Una descripción.</li>\n    <li>Un enlace a la imagen o archivo multimedia real.</li>\n    <li>Una lista de atributos o propiedades (ej. "color: rojo", "rareza: alta").</li>\n</ul>\n<h3>Marketplaces como OpenSea</h3>\n<p>Los marketplaces de NFTs como OpenSea son dApps complejas que actúan como exploradores y facilitadores de comercio. Su función es:</p>\n<ol>\n    <li>Escanear la blockchain en busca de contratos que cumplan con el estándar ERC-721.</li>\n    <li>Leer la información de propiedad de cada NFT llamando a las funciones del contrato.</li>\n    <li>Leer la URL de los metadatos de cada NFT para obtener su imagen y propiedades.</li>\n    <li>Proporcionar una interfaz de usuario para que los propietarios puedan poner a la venta sus NFTs y los compradores puedan hacer ofertas, facilitando las transacciones a través de contratos inteligentes de subasta.</li>\n</ol>', duration: 120 },
    ],
    project: {
      title: 'Aplicación descentralizada con smart contract',
      description: 'Desarrollar una dApp que interactúe con un smart contract en una red de prueba.',
    },
    quizId: 'quiz_9',
  },
  {
    id: '10',
    title: 'MÓDULO 10: Portafolio, Freelancing y Monetización',
    objective: 'Preparar al estudiante para trabajar, emprender y vender sus servicios',
    classes: [
      { id: '10.1', title: 'Cómo crear un portafolio impactante', content: '<h2>Tu Carta de Presentación al Mundo: El Portafolio de Desarrollador</h2>\n<p>En el mundo del desarrollo de software, tu <strong>portafolio es tu currículum vitae más importante</strong>. Es la demostración tangible de tus habilidades, mucho más elocuente que una lista de tecnologías en un papel. Un buen portafolio no solo muestra lo que sabes hacer, sino que también demuestra tu pasión, tu atención al detalle y tu capacidad para llevar un proyecto de la idea a la realidad.</p>\n<h3>Elementos Esenciales de un Portafolio Ganador</h3>\n<ul>\n    <li><strong>Diseño Limpio y Profesional:</strong> Tu portafolio es un proyecto en sí mismo. Debe ser visualmente agradable, fácil de navegar y, sobre todo, <strong>totalmente responsivo</strong>. La mayoría de los reclutadores lo verán tanto en escritorio como en móvil.</li>\n    <li><strong>Dominio Personalizado:</strong> Invertir en un dominio propio (ej. <code>tunombre.com</code>) demuestra profesionalismo y seriedad.</li>\n    <li><strong>Sección "Sobre Mí" y Foto:</strong> Una breve biografía que cuente tu historia, tu pasión por la tecnología y lo que te motiva. Incluir una foto profesional ayuda a crear una conexión humana.</li>\n    <li><strong>Habilidades Claras:</strong> Una sección donde enumeres las tecnologías que dominas, idealmente agrupadas por categorías (Front-End, Back-End, Bases de Datos, DevOps, IA, etc.).</li>\n    <li><strong>Información de Contacto Visible:</strong> Haz que sea increíblemente fácil para un reclutador contactarte. Un formulario de contacto y enlaces a tu perfil de LinkedIn y GitHub son imprescindibles.</li>\n</ul>\n<h3>Proyectos: La Verdadera Carne del Portafolio</h3>\n<p>Los proyectos son la parte más importante. Aquí es donde demuestras tus habilidades.</p>\n<ul>\n    <li><strong>Calidad sobre Cantidad:</strong> Es infinitamente mejor mostrar 3-4 proyectos sólidos y bien documentados que 10 pequeños tutoriales. Elige los proyectos de los que estés más orgulloso. Los proyectos de nuestros módulos son excelentes candidatos.</li>\n    <li><strong>Demo en Vivo IMPRESCINDIBLE:</strong> Nadie quiere clonar un repositorio y configurar un entorno solo para ver tu proyecto. Cada proyecto debe tener un enlace a una <strong>versión desplegada y funcional</strong>.</li>\n    <li><strong>Enlace al Código Fuente:</strong> Siempre enlaza al repositorio de GitHub. Los reclutadores técnicos querrán ver tu código, la estructura de tu proyecto y tu historial de commits.</li>\n    <li><strong>Descripción Detallada del Proyecto:</strong> Por cada proyecto, incluye:\n        <ul>\n            <li>Un <strong>resumen</strong> claro de qué es el proyecto y qué problema resuelve.</li>\n            <li>Las <strong>tecnologías</strong> utilizadas (sé específico).</li>\n            <li>Una descripción de los <strong>desafíos técnicos</strong> que enfrentaste y cómo los superaste. Esto demuestra tu capacidad para resolver problemas.</li>\n            <li>Si fue un proyecto en equipo, especifica cuál fue <strong>tu rol y tus contribuciones</strong>.</li>\n        </ul>\n    </li>\n</ul>\n<p>Tu portafolio es un documento vivo. Mantenlo actualizado a medida que aprendes nuevas tecnologías y completas nuevos proyectos. Es tu mejor herramienta para abrir puertas en tu carrera profesional.</p>', duration: 60 },
      { id: '10.2', title: 'Plataformas para encontrar trabajo (Upwork, Freelancer, etc.)', content: '<h2>Capitalizando tus Habilidades: El Mundo del Freelancing y las Plataformas de Empleo</h2>\n<p>Con un portafolio sólido en mano, es hora de llevar tus habilidades al mercado. Las plataformas en línea han democratizado el acceso al trabajo para los desarrolladores, pero la competencia es feroz. Saber cómo navegar este ecosistema es clave.</p>\n<h3>El Paisaje de las Plataformas</h3>\n<p>Existen varios tipos de plataformas, cada una con su propia dinámica:</p>\n<ul>\n    <li><strong>Plataformas de Freelance Tradicionales (Ej: Upwork, Freelancer.com):</strong> Aquí, los clientes publican proyectos y los freelancers envían propuestas. Son excelentes para encontrar trabajos de mediano a largo plazo, pero requieren un esfuerzo proactivo para escribir propuestas ganadoras.</li>\n    <li><strong>Plataformas de "Gigs" o Servicios (Ej: Fiverr):</strong> En lugar de ofertar por proyectos, aquí empaquetas tus habilidades en servicios concretos con un precio fijo (ej. "Construiré una landing page con Next.js y Tailwind"). Es un modelo excelente para empezar y construir un historial.</li>\n    <li><strong>Plataformas Exclusivas (Ej: Toptal, Braintrust):</strong> Estas plataformas tienen un proceso de selección muy riguroso (a menudo con pruebas técnicas y entrevistas). Es más difícil entrar, pero si lo logras, accedes a clientes de primer nivel y tarifas mucho más altas.</li>\n</ul>\n<h3>Creando un Perfil que Atrape Clientes</h3>\n<p>Tu perfil en estas plataformas es una extensión de tu portafolio. Debe ser impecable.</p>\n<ol>\n    <li><strong>Especialízate:</strong> No te presentes como un "desarrollador que hace de todo". Un título como "Desarrollador Full-Stack especializado en Next.js, Firebase y IA para Startups" es mucho más potente.</li>\n    <li><strong>Headline Atractivo:</strong> Tu titular es lo primero que ve un cliente. Debe comunicar valor. "Convierto tus ideas en aplicaciones web rápidas y escalables" es mejor que "Programador con 5 años de experiencia".</li>\n    <li><strong>Descripción Orientada a Beneficios:</strong> En tu biografía, no solo listes tus habilidades. Explica cómo esas habilidades benefician al cliente (ej. "Construyo interfaces rápidas para mejorar la retención de usuarios" o "Implemento backends seguros para proteger tus datos").</li>\n    <li><strong>Portafolio Visual y Pruebas Sociales:</strong> Sube tus mejores proyectos directamente a la plataforma. Las reseñas de clientes anteriores son tu activo más valioso.</li>\n</ol>\n<h3>El Arte de la Propuesta Ganadora</h3>\n<p>Para plataformas como Upwork, tu propuesta lo es todo.</p>\n<ul>\n    <li><strong>Personalización Extrema:</strong> NUNCA uses plantillas. Demuestra que has leído y entendido el problema del cliente. Menciona detalles específicos de su publicación.</li>\n    <li><strong>No Hables de Ti, Habla de Ellos:</strong> Empieza abordando su problema y cómo planeas resolverlo.</li>\n    <li><strong>Propón Siguientes Pasos:</strong> Termina con una llamada a la acción clara, como "Me encantaría discutir esto en una breve llamada de 15 minutos para aclarar algunos detalles".</li>\n    <li><strong>Fijación de Precios:</strong> Investiga el mercado, pero no compitas por ser el más barato. Compite por valor. Justifica tus tarifas basándote en la calidad de tu trabajo y los resultados que puedes ofrecer.</li>\n</ul>', duration: 90 },
      { id: '10.3', title: 'Marca personal y networking', content: '<h2>Más Allá del Código: Construyendo tu Marca Personal y Red de Contactos</h2>\n<p>En un mercado tecnológico competitivo, tus habilidades técnicas son la base, pero tu <strong>marca personal</strong> y tu <strong>red de contactos (networking)</strong> son los aceleradores de tu carrera. No se trata de ser un "influencer", sino de construir una reputación profesional que te abra puertas y te posicione como un experto en tu nicho.</p>\n<h3>¿Qué es la Marca Personal para un Desarrollador?</h3>\n<p>Tu marca personal es la percepción que otros tienen de ti profesionalmente. Es la respuesta a la pregunta: "¿Por qué debería contratarte a ti y no a otro desarrollador?". Se compone de:\n-   <strong>Tu Especialización:</strong> ¿Eres el experto en Next.js y IA? ¿El mago de la optimización de rendimiento? ¿El especialista en seguridad de dApps?\n-   <strong>Tu Contenido:</strong> Lo que compartes con el mundo (proyectos, artículos, posts).\n-   <strong>Tu Comunicación:</strong> Cómo interactúas en línea y en persona.</p>\n<h3>Construyendo tu Marca Paso a Paso</h3>\n<ol>\n    <li><strong>Define tu Nicho:</strong> No puedes ser un experto en todo. Elige el área que más te apasione y en la que quieras ser reconocido. Tu especialización te hace memorable.</li>\n    <li><strong>Optimiza tu Presencia Online:</strong>\n        <ul>\n            <li><strong>LinkedIn:</strong> Es tu CV dinámico. Completa tu perfil al 100%, usa una foto profesional y un titular que refleje tu especialización. Comparte tus proyectos, escribe artículos cortos sobre lo que estás aprendiendo y comenta de forma inteligente en las publicaciones de otros.</li>\n            <li><strong>GitHub:</strong> Tu perfil de GitHub es parte de tu marca. Asegúrate de que tus proyectos principales estén "pineados" y que tus READMEs sean excelentes.</li>\n            <li><strong>Twitter/X (Opcional):</strong> Es una herramienta poderosa para conectar con otros desarrolladores, seguir a líderes de la industria y participar en conversaciones técnicas en tiempo real.</li>\n        </ul>\n    </li>\n    <li><strong>Crea y Comparte Conocimiento:</strong> La forma más rápida de establecerte como experto es enseñar lo que sabes. No necesitas ser un gurú mundial. Simplemente documenta tu viaje de aprendizaje. Escribe un post sobre un problema que resolviste, comparte un fragmento de código útil o graba un vídeo corto explicando un concepto.</li>\n</ol>\n<h3>El Networking no es una "Mala Palabra"</h3>\n<p>Networking no significa pedir trabajo. Significa <strong>construir relaciones auténticas basadas en el valor mutuo</strong>.</p>\n<ul>\n    <li><strong>Aporta Valor Primero:</strong> Antes de pedir algo, ofrece ayuda. Responde preguntas en foros, participa en discusiones en Discord/Slack o contribuye a un proyecto de código abierto.</li>\n    <li><strong>Contribuciones a Open Source:</strong> Es una de las formas más efectivas de networking. Te pone en contacto directo con otros desarrolladores, demuestra tus habilidades y construye tu reputación de forma orgánica.</li>\n    <li><strong>Asiste a Eventos (Online y Presenciales):</strong> Los meetups, hackathons y conferencias son lugares excelentes para conocer gente con tus mismos intereses.</li>\n</ul>', duration: 90 },
      { id: '10.4', title: 'Monetizar tus aplicaciones', content: '<h2>Del Código al Dinero: Estrategias para Monetizar tus Proyectos Personales</h2>\n<p>Ser capaz de construir una aplicación es solo la mitad de la ecuación. La otra mitad es saber cómo convertir esa creación en una fuente de ingresos. Esta lección explora los modelos de negocio más comunes para los desarrolladores que quieren emprender.</p>\n<h3>El Cambio de Mentalidad: De Proveedor de Servicios a Dueño de Producto</h3>\n<p>Monetizar una aplicación requiere un cambio de enfoque. Ya no vendes tu tiempo (como en el freelancing), sino que vendes una <strong>solución a un problema</strong>. Esto implica entender a tu público objetivo, identificar un problema que estén dispuestos a pagar por resolver y construir un producto que lo haga de manera efectiva.</p>\n<h3>Modelos de Monetización Populares</h3>\n<ol>\n    <li><strong>SaaS (Software como Servicio):</strong> Es el modelo dominante para las aplicaciones web. Los usuarios pagan una tarifa recurrente (generalmente mensual o anual) por el acceso al software.\n        <ul>\n            <li><strong>Suscripciones por Niveles (Tiered Subscriptions):</strong> Ofrecer diferentes planes (ej. Básico, Pro, Empresarial) con distintas características y límites. Es el modelo más común.</li>\n            <li><strong>Modelo Freemium:</strong> Proporcionar una versión gratuita y funcional del producto con características limitadas para atraer a una gran base de usuarios, con la esperanza de convertir a un porcentaje de ellos en clientes de pago.</li>\n            <li><strong>Pago por Uso (Pay-as-you-go):</strong> Cobrar a los usuarios en función de su consumo. Es ideal para servicios de API o de infraestructura, donde el coste para el proveedor está directamente ligado al uso.</li>\n        </ul>\n    </li>\n    <li><strong>Venta Única (One-Time Purchase):</strong> El usuario paga una vez para obtener acceso a la aplicación o a un recurso.\n        <ul>\n            <li><strong>Licencias de por Vida:</strong> El cliente compra la versión actual del software y puede usarla indefinidamente.</li>\n            <li><strong>Venta de Recursos Digitales:</strong> Un modelo excelente para desarrolladores. Puedes vender plantillas, kits de UI, boilerplates de código, cursos o e-books.</li>\n        </ul>\n    </li>\n    <li><strong>Modelos Basados en Audiencia:</strong> Si tu aplicación atrae a mucho tráfico pero los usuarios no están dispuestos a pagar directamente.\n        <ul>\n            <li><strong>Publicidad (Advertising):</strong> Integrar anuncios a través de redes como Google AdSense.</li>\n            <li><strong>Marketing de Afiliados:</strong> Recomendar productos o servicios de terceros y ganar una comisión por cada venta referida.</li>\n        </ul>\n    </li>\n</ol>\n<h3>La Pila Tecnológica de la Monetización</h3>\n<p>No necesitas construir un sistema de pagos desde cero. Herramientas como <strong>Stripe</strong> y <strong>Lemon Squeezy</strong> son el estándar de la industria. Ofrecen APIs y componentes de UI que facilitan enormemente la integración de pagos, la gestión de suscripciones, la facturación y el cumplimiento de las normativas fiscales.</p>', duration: 120 },
      { id: '10.5', title: 'Estrategias básicas de marketing digital para programadores', content: '<h2>Haciendo que te Encuentren: Marketing Digital para Quienes Crean</h2>\n<p>Has construido un producto increíble. Ahora, ¿cómo se entera el mundo de él? El marketing no tiene por qué ser complicado o caro. Para un desarrollador, a menudo se trata de compartir auténticamente su trabajo y su conocimiento en los lugares correctos.</p>\n<h3>1. Marketing de Contenidos: Tu Mejor Aliado</h3>\n<p>Ya lo mencionamos para la marca personal, pero es también la estrategia de marketing más potente. Escribe sobre tu viaje construyendo el producto. Publica artículos de blog sobre los desafíos técnicos que superaste, las decisiones de arquitectura que tomaste o cómo tu producto resuelve un problema específico. Esto no solo demuestra tu experiencia, sino que también atrae a personas interesadas en esos temas a través de los motores de búsqueda.</p>\n<h3>2. SEO para Desarrolladores (On-Page Básico)</h3>\n<p>No necesitas ser un experto en SEO. Concéntrate en lo básico para que Google entienda de qué trata tu página:\n    <ul>\n        <li><strong>Títulos Descriptivos:</strong> Usa la etiqueta <code>&lt;title&gt;</code> de tu página para describir claramente lo que hace tu producto.</li>\n        <li><strong>URLs Semánticas:</strong> Una URL como <code>mi-app.com/generador-de-facturas</code> es mejor que <code>mi-app.com/tool?id=123</code>.</li>\n        <li><strong>Meta Descripciones:</strong> Escribe un resumen de 1-2 frases sobre tu producto. Es lo que aparece debajo del título en los resultados de búsqueda de Google.</li>\n    </ul>\n</p>\n<h3>3. Lanzamiento en Comunidades: Consigue tus Primeros Usuarios</h3>\n<p>Una vez que tu producto esté listo, lánzalo donde otros desarrolladores y "early adopters" pasan el tiempo. No lo anuncies como spam, sino comparte tu historia y pide feedback.</p>\n<ul>\n    <li><strong>Product Hunt:</strong> Es la plataforma de lanzamiento por excelencia para nuevos productos tecnológicos.</li>\n    <li><strong>Hacker News (Show HN):</strong> La comunidad de Y Combinator es muy técnica y ofrece feedback valioso.</li>\n    <li><strong>Reddit:</strong> Encuentra subreddits relevantes para tu producto (ej. <code>r/SideProject</code>, <code>r/webdev</code>, o comunidades específicas de tu nicho).</li>\n</ul>\n<h3>4. El Activo Más Valioso: Tu Lista de Correo</h3>\n<p>Desde el día uno, incluso si tu producto aún no está listo, pon un formulario simple en tu landing page para capturar direcciones de correo electrónico de gente interesada. Una lista de correo es una línea de comunicación directa con tus usuarios más leales. Úsala para anunciar nuevas características, pedir feedback y, eventualmente, promocionar ofertas.</p>', duration: 120 },
    ],
    project: {
      title: 'Lanzamiento de tu marca personal',
      description: 'Crear un portafolio profesional, perfiles en plataformas de freelancing y una estrategia de monetización.',
    },
    quizId: 'quiz_10',
  },
  {
    id: '11',
    title: 'MÓDULO 11: Proyecto Final',
    objective: 'Desarrollar un proyecto profesional completo',
    classes: [],
    project: {
      title: 'App full stack con IA o Web3 integrada',
      description: 'Incluye: diseño, frontend, backend, seguridad, deploy, documentación y defensa oral del proyecto.',
    }
  },
  {
    id: '12',
    title: 'MÓDULO 12: Nivel Master',
    objective: 'Dominar arquitectura avanzada, patrones y escalabilidad',
    classes: [
      { id: '12.1', title: 'Arquitectura limpia', content: '<h2>La Siguiente Frontera: De Código que Funciona a Código que Perdura</h2>\n<p>A lo largo de este curso, hemos aprendido a construir aplicaciones funcionales y completas. Sin embargo, a medida que un proyecto crece en tamaño y complejidad, una nueva pregunta se vuelve crucial: ¿cómo organizamos nuestro código para que sea <strong>fácil de mantener, de probar y de adaptar</strong> a futuros cambios? La respuesta está en la <strong>arquitectura de software</strong>.</p>\n<p>La <strong>Arquitectura Limpia (Clean Architecture)</strong>, popularizada por Robert C. Martin ("Uncle Bob"), es un conjunto de principios de diseño que busca la <strong>separación de preocupaciones</strong>. Su objetivo es crear sistemas donde la lógica de negocio del núcleo de la aplicación no dependa de los detalles de implementación, como el framework web, la base de datos o la interfaz de usuario.</p>\n<h3>La Regla de la Dependencia: El Corazón de la Arquitectura Limpia</h3>\n<p>El principio fundamental es simple pero profundo: <strong>las dependencias del código fuente solo pueden apuntar hacia adentro</strong>. Imagina la aplicación como una serie de círculos concéntricos:</p>\n<ul>\n    <li><strong>Círculo más Interno (Entidades):</strong> Contiene las reglas de negocio más generales y de alto nivel de la empresa. Son los objetos y la lógica que menos cambian.</li>\n    <li><strong>Círculo de Casos de Uso (Use Cases):</strong> Contiene la lógica de la aplicación específica. Orquesta el flujo de datos desde y hacia las entidades. Nuestros "flows" de Genkit o las Server Actions son buenos ejemplos de casos de uso.</li>\n    <li><strong>Círculo de Adaptadores de Interfaz (Interface Adapters):</strong> Es una capa de "traductores". Convierte los datos del formato más conveniente para los casos de uso al formato más conveniente para agentes externos como la base de datos o la web.</li>\n    <li><strong>Círculo más Externo (Frameworks y Drivers):</strong> Aquí residen los detalles. La UI (React, Next.js), la base de datos (PostgreSQL), el servidor web. Esta capa es volátil y cambia con el tiempo.</li>\n</ul>\n<p>La regla de la dependencia significa que el código en una capa interna no puede saber nada sobre el código en una capa externa. Un caso de uso no sabe si la UI es una aplicación web o una de consola. Las entidades no saben qué base de datos se está utilizando.</p>\n<h3>Beneficios en un Entorno Real</h3>\n<ul>\n    <li><strong>Independencia del Framework:</strong> Tu lógica de negocio no está atada a Next.js. Si en el futuro aparece un framework mejor, puedes migrar con mucho menos esfuerzo.</li>\n    <li><strong>Testeabilidad:</strong> Puedes probar la lógica de negocio del núcleo sin necesidad de un servidor web o una base de datos, haciendo que las pruebas sean rápidas y fiables.</li>\n    <li><strong>Independencia de la UI y la Base de Datos:</strong> Puedes cambiar la base de datos o rediseñar la interfaz de usuario sin que esto afecte a la lógica de negocio.</li>\n</ul>\n<p>Dominar estos principios es lo que diferencia a un programador de un arquitecto de software, permitiéndote construir sistemas robustos que pueden evolucionar y prosperar durante años.</p>', duration: 60 },
      { id: '12.2', title: 'Monolitos vs Microservicios', content: '<h2>La Decisión Arquitectónica Clave: Monolitos vs. Microservicios</h2>\n<p>A medida que una aplicación crece, surge una pregunta fundamental sobre cómo estructurarla. Hay dos enfoques principales: el monolito y los microservicios.</p>\n<h3>El Enfoque Tradicional: El Monolito</h3>\n<p>Un <strong>monolito</strong> es una aplicación donde todos los componentes (interfaz de usuario, lógica de negocio, acceso a datos) están acoplados en una única base de código y se despliegan como una sola unidad. Para proyectos pequeños y medianos, este es a menudo el enfoque más simple y rápido.</p>\n<ul>\n    <li><strong>Ventajas:</strong> Desarrollo simplificado, despliegue sencillo y sin latencia de red entre componentes.</li>\n    <li><strong>Desventajas:</strong> Dificultad para escalar partes individuales de la aplicación, un error puede detener todo el sistema, y el desarrollo puede volverse lento y complejo a medida que el proyecto crece.</li>\n</ul>\n<h3>El Enfoque Moderno: Los Microservicios</h3>\n<p>Los <strong>microservicios</strong> son un estilo de arquitectura que estructura una aplicación como una colección de servicios pequeños, autónomos y débilmente acoplados. Cada servicio se centra en una capacidad de negocio específica, tiene su propia base de datos y se puede desplegar de forma independiente.</p>\n<ul>\n    <li><strong>Ventajas:</strong> Escalabilidad granular (puedes escalar solo los servicios que lo necesitan), resiliencia (la falla de un servicio no detiene toda la aplicación), y flexibilidad tecnológica (cada servicio puede usar el stack tecnológico más apropiado).</li>\n    <li><strong>Desventajas:</strong> Aumentan drásticamente la complejidad operativa (necesitas gestionar la comunicación entre servicios, el descubrimiento, la monitorización) y introducen latencia de red.</li>\n</ul>\n<h3>La Estrategia "Monolith-First"</h3>\n<p>Para la mayoría de los proyectos, la recomendación es empezar con un <strong>monolito bien estructurado</strong>. La complejidad de los microservicios es a menudo una optimización prematura. Si el monolito está diseñado siguiendo principios de Arquitectura Limpia (con una clara separación de preocupaciones), se puede "romper" en microservicios más adelante si la escala del negocio lo justifica. Frameworks como Next.js, con su capacidad para desplegar partes de la aplicación como funciones serverless, ofrecen un excelente punto intermedio.</p>', duration: 90 },
      { id: '12.3', title: 'Patrones de diseño (Factory, Singleton, etc.)', content: '<h2>Vocabulario para Soluciones Elegantes: Patrones de Diseño</h2>\n<p>Los <strong>Patrones de Diseño</strong> son soluciones reutilizables y probadas a problemas comunes que surgen en el diseño de software. No son código que se copia y pega, sino "recetas" o plantillas conceptuales que se adaptan a un contexto específico. Dominarlos te proporciona un vocabulario para comunicarte con otros desarrolladores y te permite construir sistemas más flexibles y mantenibles.</p>\n<h3>¿Por Qué Son Importantes?</h3>\n<ul>\n    <li><strong>Lenguaje Común:</strong> Permiten comunicar ideas complejas de diseño de forma concisa. Decir "usemos un Singleton aquí" es más rápido que describir toda la implementación.</li>\n    <li><strong>Soluciones Probadas:</strong> Han sido refinados por innumerables desarrolladores a lo largo del tiempo, ayudándote a evitar errores comunes.</li>\n    <li><strong>Flexibilidad:</strong> Promueven un bajo acoplamiento, lo que facilita la modificación y extensión del sistema en el futuro.</li>\n</ul>\n<h3>Patrones Esenciales para el Desarrollo Web</h3>\n<p>Nos centraremos en algunos de los más relevantes para nuestro stack:</p>\n<ul>\n    <li><strong>Singleton (Creacional):</strong> Garantiza que una clase tenga una única instancia y proporciona un punto de acceso global a ella. <strong>Caso de uso:</strong> Gestionar un recurso compartido, como una conexión a una base de datos o la inicialización de un servicio. Nuestro archivo <code>lib/firebase.ts</code>, que se asegura de que Firebase solo se inicialice una vez (<code>if (!getApps().length)</code>), es una implementación práctica del espíritu de este patrón.</li>\n    <li><strong>Factory Method (Creacional):</strong> Define una interfaz para crear un objeto, pero deja que sean las subclases quienes decidan qué clase concreta instanciar. <strong>Caso de uso:</strong> Imagina un sistema que necesita crear diferentes tipos de notificaciones (Email, SMS, Push). Una "Fábrica de Notificaciones" podría recibir el tipo y los datos, y devolver el objeto de notificación correcto sin que el código cliente necesite saber cómo se construye cada uno.</li>\n    <li><strong>Adapter (Estructural):</strong> Convierte la interfaz de una clase en otra interfaz que los clientes esperan. Permite que clases con interfaces incompatibles trabajen juntas. <strong>Caso de uso:</strong> Si tu aplicación depende de una API de terceros, puedes crear una clase "Adaptador" que envuelva las llamadas a esa API. Si la API cambia en el futuro, solo necesitas modificar el adaptador, y no todo el código de tu aplicación que la consumía.</li>\n    <li><strong>Observer (Comportamiento):</strong> Define una dependencia de uno-a-muchos entre objetos, de manera que cuando un objeto (el "sujeto") cambia de estado, todos sus dependientes (los "observadores") son notificados y actualizados automáticamente. <strong>Caso de uso:</strong> ¡La reactividad en React! Cuando llamas a <code>setState</code>, el componente (sujeto) notifica a React, que a su vez actualiza la UI (observador). Los hooks como <code>useEffect</code> son una forma de suscribir un componente a cambios en otros datos.</li>\n</ul>', duration: 90 },
      { id: '12.4', title: 'Webs de alto tráfico y escalabilidad', content: '<h2>El Desafío del Éxito: Arquitecturas para la Alta Concurrencia</h2>\n<p>Una cosa es construir una aplicación que funcione, y otra muy distinta es construir una que pueda soportar a millones de usuarios simultáneamente sin caerse. La <strong>escalabilidad</strong> es la capacidad de un sistema para manejar una carga de trabajo creciente.</p>\n<h3>Escalabilidad Vertical vs. Horizontal</h3>\n<ul>\n    <li><strong>Escalado Vertical ("Scale Up"):</strong> Consiste en hacer más potente un único servidor (más CPU, más RAM, un SSD más rápido). Es fácil de implementar al principio, pero tiene un límite físico y un coste que crece exponencialmente.</li>\n    <li><strong>Escalado Horizontal ("Scale Out"):</strong> Consiste en añadir más servidores para distribuir la carga entre ellos. Este es el enfoque estándar para las aplicaciones web modernas, ya que es más flexible y rentable a gran escala.</li>\n</ul>\n<h3>Estrategias Clave para la Escalabilidad Horizontal</h3>\n<p>Para que una aplicación escale horizontalmente, debemos diseñarla con varias técnicas en mente:</p>\n<ol>\n    <li><strong>Balanceo de Carga (Load Balancing):</strong> Un balanceador de carga es un servidor que se sitúa frente a tus servidores de aplicación y distribuye el tráfico entrante de manera equitativa entre ellos. Es la pieza central del escalado horizontal.</li>\n    <li><strong>Caching en Múltiples Capas:</strong> El caching es la estrategia más efectiva para reducir la carga. Se debe aplicar en todas las capas posibles:\n        <ul>\n            <li><strong>CDN (Content Delivery Network):</strong> Para servir activos estáticos (imágenes, CSS, JS) desde el borde de la red, cerca del usuario.</li>\n            <li><strong>Cache de Base de Datos (ej. Redis, Memcached):</strong> Almacenar en memoria los resultados de las consultas más frecuentes para evitar golpear la base de datos constantemente.</li>\n            <li><strong>Cache a Nivel de Aplicación:</strong> Next.js, por ejemplo, tiene mecanismos de caching integrados para las renderizaciones del servidor.</li>\n        </ul>\n    </li>\n    <li><strong>Escalado de la Base de Datos:</strong> A menudo, la base de datos es el primer cuello de botella. Las estrategias para escalarla incluyen:\n        <ul>\n            <li><strong>Réplicas de Lectura (Read Replicas):</strong> Crear copias de la base de datos dedicadas a las operaciones de lectura, liberando a la base de datos principal para que se centre en las escrituras.</li>\n            <li><strong>Sharding:</strong> Una técnica más avanzada que consiste en particionar la base de datos horizontalmente, distribuyendo las filas de una tabla entre múltiples servidores.</li>\n        </ul>\n    </li>\n    <li><strong>Procesamiento Asíncrono con Colas de Mensajes:</strong> Para tareas largas o pesadas (como procesar un vídeo, enviar miles de correos electrónicos), no se deben ejecutar en el hilo principal de la aplicación. En su lugar, se "encolan" en un sistema de mensajería (como RabbitMQ o AWS SQS) y son procesadas por "workers" en segundo plano.</li>\n    <li><strong>Arquitecturas Serverless:</strong> Plataformas como Vercel o AWS Lambda, que ejecutan código en respuesta a eventos, escalan automáticamente por diseño. Desplegar tu backend de Next.js en estas plataformas te abstrae de gran parte de la gestión de la escalabilidad.</li>\n</ol>', duration: 120 },
      { id: '12.5', title: 'Testing avanzado y automatización', content: '', duration: 120 },
    ],
    project: {
      title: 'Refactorización y optimización de un proyecto existente',
      description: 'Aplicar patrones de diseño y arquitecturas avanzadas para mejorar un proyecto anterior.',
    },
    quizId: 'quiz_12',
  },
  {
    id: '13',
    title: 'MÓDULO 13: Nivel Doctorado (Investigación e innovación)',
    objective: 'Conectar ciencia, ética y futuro de la programación',
    classes: [
      { id: '13.1', title: 'Ética en la IA y tecnología', content: '', duration: 60 },
      { id: '13.2', title: 'Filosofía computacional y pensamiento crítico', content: '', duration: 90 },
      { id: '13.3', title: 'Tecnologías emergentes (Quantum computing, computación evolutiva)', content: '', duration: 90 },
      { id: '13.4', title: 'Publicación de papers y proyectos open-source', content: '', duration: 120 },
    ],
    project: {
      title: 'Propuesta de innovación tecnológica o tesis técnica',
      description: 'Desarrollar una propuesta de investigación o un proyecto open-source innovador.',
    },
    quizId: 'quiz_13',
  },
];






    

    



















    




